/* Architecture Note #1: Generating the SDK

Most SDK from API generator are very opinionated on how the
 users will use it. We wanted to have a very simple API to
 be able to customize it at will.

This file simply eats an OpenAPI file and generate
 the SDK to avoid boilerplate code.

A small article about why and how to do that:
https://insertafter.com/en/blog/considerations_for_generating_api_clients.html
*/

/**
 * @module openapi-ts-sdk-builder
 */

import camelCase from 'camelcase';
import { getOpenAPIOperations } from '@whook/http-router/dist/utils';
import SwaggerParser from '@apidevtools/swagger-parser';
import { generateOpenAPITypes, toSource } from 'schema2dts';
import type { OpenAPIV3 } from 'openapi-types';

/**
 * Build a JS SDK from an OpenAPI file
 *
 * @async
 * @method generateSDKFromOpenAPI
 * @param {String} openAPIContent
 * @param {String} sdkVersion
 * @return {Promise<string>} The SDK JS code
 */
export async function generateSDKFromOpenAPI(
  openAPIContent: string,
  sdkVersion: string,
  sdkName = 'API',
) {
  const API = JSON.parse(openAPIContent);
  const $refs = await SwaggerParser.resolve(API as any);
  const operations = getOpenAPIOperations(API);
  const dereference = <T>(maybeARef: OpenAPIV3.ReferenceObject | T) => {
    return (maybeARef as OpenAPIV3.ReferenceObject).$ref
      ? ($refs.get((maybeARef as OpenAPIV3.ReferenceObject).$ref) as Exclude<
          typeof maybeARef,
          OpenAPIV3.ReferenceObject
        >)
      : (maybeARef as Exclude<typeof maybeARef, OpenAPIV3.ReferenceObject>);
  };

  const sdkTypesName = sdkName + 'Types';
  const content = `/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
type QueryParams = {
  [name: string]: string | number | Array<string>[] | Array<number>[];
};
type Headers = { [name: string]: string };

${toSource(await generateOpenAPITypes(API, sdkTypesName))}

import type { AxiosRequestConfig } from 'axios';
import querystring from 'querystring';
import axios from 'axios';

/**
 * ${API.info.description}
 * @module API
 * @version ${API.info.version}
 */
const API = {
  ${operations.map(({ operationId }) => operationId).join(',\n  ')},
};

${operations
  .map((operation) => {
    const { path, method, operationId, parameters, requestBody } = operation;
    const dereferencedParameters = (parameters || []).map((parameter) =>
      dereference(parameter),
    );

    return `
/**
 * ${operation.summary}
 * @param {Object} parameters
 * The parameters to provide (destructured)${
   requestBody
     ? `
  @param body The request body
`
     : ''
 }${dereferencedParameters
      .filter(
        (p) =>
          !['X-API-Version', 'X-SDK-Version', 'X-Application-Version'].includes(
            p.name,
          ),
      )
      .map(
        (parameter) => `
 * @param {${
   parameter.schema
     ? (parameter.schema as OpenAPIV3.BaseSchemaObject).oneOf
       ? [
           ...new Set(
             (parameter.schema as OpenAPIV3.BaseSchemaObject).oneOf.map((s) => {
               const dereferencedSchema = (s as OpenAPIV3.ReferenceObject).$ref
                 ? ($refs.get((s as OpenAPIV3.ReferenceObject).$ref) as Exclude<
                     typeof s,
                     OpenAPIV3.ReferenceObject
                   >)
                 : (s as Exclude<typeof s, OpenAPIV3.ReferenceObject>);

               return dereferencedSchema.type;
             }),
           ),
         ].join('|')
       : ((parameter.schema as OpenAPIV3.ReferenceObject).$ref
           ? ($refs.get(
               (parameter.schema as OpenAPIV3.ReferenceObject).$ref,
             ) as Exclude<typeof parameter.schema, OpenAPIV3.ReferenceObject>)
           : ((parameter.schema as Exclude<
               typeof parameter.schema,
               OpenAPIV3.ReferenceObject
             >) as OpenAPIV3.NonArraySchemaObject)
         ).type
     : 'any'
 }} ${parameter.required ? `` : `[`}parameters.${camelCase(parameter.name)}${
          parameter.required ? `` : `]`
        }${
          parameter.description
            ? `
 * ${parameter.description}`
            : ''
        }`,
      )}
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function ${operationId}(${
      requestBody || (dereferencedParameters && dereferencedParameters.length)
        ? `
  {${
    requestBody
      ? `
    body,`
      : ''
  }${dereferencedParameters
            .filter((p) => !['X-API-Version', 'X-SDK-Version'].includes(p.name))
            .map((parameter) => {
              const variableName = camelCase(parameter.name);

              return `\n  ${variableName},`;
            })
            .join('')}
  } : ${sdkTypesName}.${
            operationId[0].toUpperCase() + operationId.slice(1)
          }.Input`
        : `
  _: unknown`
    },
  options: AxiosRequestConfig = {}
) : Promise<Writeable<${sdkTypesName}.${
      operationId[0].toUpperCase() + operationId.slice(1)
    }.Output>> {

${dereferencedParameters
  .map((parameter) => {
    if (parameter.required) {
      return `
  if( ${camelCase(parameter.name)} == null) {
    throw new Error('Missing required parameter : ${camelCase(
      parameter.name,
    )}. Value : ' +  ${camelCase(parameter.name)});
  }
`;
    }
  })
  .join('')}

  const method = '${method}';
  const urlParts = [${path
    .split('/')
    .filter((identity) => identity)
    .map((part) => {
      const result = /^{([a-z0-9]+)}$/gi.exec(part);

      if (result) {
        return `
    ${camelCase(result[1])},`;
      }
      return `
    '${part}',`;
    })
    .join('')}
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '${API.info.version}',${
      sdkVersion
        ? `
    'X-SDK-Version': '${sdkVersion}',`
        : ''
    }${dereferencedParameters
      .filter((p) => 'header' === p.in)
      .filter((p) => !['X-API-Version', 'X-SDK-Version'].includes(p.name))
      .map(
        (parameter) => `
    '${parameter.name}': ${camelCase(parameter.name)},`,
      )
      .join('')}
  });
  const qs = cleanQuery({${dereferencedParameters
    .filter((p) => 'query' === p.in)
    .map(
      (parameter) => `
    ${parameter.name}: ${camelCase(parameter.name)}${
        (parameter as any).ordered ? '.sort(sortMultipleQuery)' : ''
      },`,
    )
    .join('')}
  });
  const data = ${requestBody ? 'body' : 'undefined'};

  const response = await axios(Object.assign({
    baseURL: '${API.servers[0].url}',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as ${sdkTypesName}.${
      operationId[0].toUpperCase() + operationId.slice(1)
    }.Output;
}`;
  })
  .join('\n')}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as Array<any>).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {});
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {});
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
`;

  return content;
}

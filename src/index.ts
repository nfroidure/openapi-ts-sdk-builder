/* Architecture Note #1: Generating the SDK

Most SDK from API generator are very opinionated on how the
 users will use it. We wanted to have a very simple API to
 be able to customize it at will.

This file simply eats an OpenAPI file and generate
 the SDK to avoid boilerplate code.

A small article about why and how to do that:
https://insertafter.com/en/blog/considerations_for_generating_api_clients.html
*/

/**
 * @module openapi-ts-sdk-builder
 */

import camelCase from 'camelcase';
import { getOpenAPIOperations } from '@whook/http-router';
import SwaggerParser from '@apidevtools/swagger-parser';
import { generateOpenAPITypes, toSource } from 'schema2dts';
import type { OpenAPIV3 } from 'openapi-types';

export enum HttpLib {
  Axios = 'Axios',
  Ky = 'Ky',
}

/**
 * Build a JS SDK from an OpenAPI file
 *
 * @async
 * @method generateSDKFromOpenAPI
 * @param {string} openAPIContent
 * @param {Object} options
 * @param {string} options.sdkVersion
 * @param {string} [options.sdkName]
 * @param {string} [options.ignoredParametersNames]
 * @param {string} [options.undocumentedParametersNames]
 * @return {Promise<string>} The SDK JS code
 */
export async function generateSDKFromOpenAPI(
  openAPIContent: string,
  {
    sdkVersion,
    sdkName = 'API',
    ignoredParametersNames = [],
    undocumentedParametersNames = [],
    filterStatuses = [],
    httpLib = HttpLib.Axios,
  }: {
    sdkVersion: string;
    sdkName?: string;
    ignoredParametersNames?: string[];
    undocumentedParametersNames?: string[];
    filterStatuses?: number[];
    httpLib?: HttpLib;
  },
): Promise<string> {
  const API = JSON.parse(openAPIContent);
  const $refs = await SwaggerParser.resolve(API as never);
  const operations = getOpenAPIOperations(API);
  const dereference = <T>(maybeARef: OpenAPIV3.ReferenceObject | T) => {
    return (maybeARef as OpenAPIV3.ReferenceObject).$ref
      ? ($refs.get((maybeARef as OpenAPIV3.ReferenceObject).$ref) as Exclude<
          typeof maybeARef,
          OpenAPIV3.ReferenceObject
        >)
      : (maybeARef as Exclude<typeof maybeARef, OpenAPIV3.ReferenceObject>);
  };

  const sdkTypesName = sdkName + 'Types';
  const content = `/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
type Headers = Record<string, string>;

export type { APITypes, Components };

${toSource(await generateOpenAPITypes(API, sdkTypesName, { filterStatuses }))}

${getImports(httpLib)}

/**
 * ${API.info.description}
 * @module API
 * @version ${API.info.version}
 */
const API = {
  ${operations.map(({ operationId }) => operationId).join(',\n  ')},
};

${operations
  .map((operation) => {
    const { path, method, operationId, parameters, requestBody } = operation;
    const dereferencedParameters = (parameters || [])
      .map((parameter) => dereference(parameter))
      .filter((p) => !ignoredParametersNames.includes(p.name));

    return `
/**
 * ${operation.summary}
 * @param {Object} parameters
 * The parameters to provide (destructured)${
   requestBody
     ? `
  @param body The request body
`
     : ''
 }${dereferencedParameters
      .filter((p) => !undocumentedParametersNames.includes(p.name))
      .map(
        (parameter) => `
 * @param {${
   parameter.schema
     ? (parameter.schema as OpenAPIV3.BaseSchemaObject).oneOf
       ? [
           ...new Set(
             (parameter.schema as OpenAPIV3.BaseSchemaObject).oneOf.map((s) => {
               const dereferencedSchema = (s as OpenAPIV3.ReferenceObject).$ref
                 ? ($refs.get((s as OpenAPIV3.ReferenceObject).$ref) as Exclude<
                     typeof s,
                     OpenAPIV3.ReferenceObject
                   >)
                 : (s as Exclude<typeof s, OpenAPIV3.ReferenceObject>);

               return dereferencedSchema.type;
             }),
           ),
         ].join('|')
       : ((parameter.schema as OpenAPIV3.ReferenceObject).$ref
           ? ($refs.get(
               (parameter.schema as OpenAPIV3.ReferenceObject).$ref,
             ) as Exclude<typeof parameter.schema, OpenAPIV3.ReferenceObject>)
           : ((parameter.schema as Exclude<
               typeof parameter.schema,
               OpenAPIV3.ReferenceObject
             >) as OpenAPIV3.NonArraySchemaObject)
         ).type
     : 'any'
 }} ${parameter.required ? `` : `[`}parameters.${camelCase(parameter.name)}${
          parameter.required ? `` : `]`
        }${
          parameter.description
            ? `
 * ${parameter.description}`
            : ''
        }`,
      )}
 * @param {Object} options
 * Options to override ${getHttpLibName(httpLib)} request configuration
 * @return {Object}
 * The HTTP response
 */
async function ${operationId}(${
      requestBody || (dereferencedParameters && dereferencedParameters.length)
        ? `
  {${
    requestBody
      ? `
    body,`
      : ''
  }${dereferencedParameters
            .map((parameter) => {
              const variableName = camelCase(parameter.name);

              return `\n  ${variableName},`;
            })
            .join('')}
  } : ${sdkTypesName}.${
            operationId[0].toUpperCase() + operationId.slice(1)
          }.Input`
        : `
  _: unknown`
    },
  options: ${getOptionsHttpLib(httpLib)} = {}
) : Promise<Writeable<${sdkTypesName}.${
      operationId[0].toUpperCase() + operationId.slice(1)
    }.Output>> {

${dereferencedParameters
  .map((parameter) => {
    if (parameter.required) {
      return `
  if( ${camelCase(parameter.name)} == null) {
    throw new Error('Missing required parameter : ${camelCase(
      parameter.name,
    )}. Value : ' +  ${camelCase(parameter.name)});
  }
`;
    }
  })
  .join('')}

  const method = '${method}';
  const urlParts = [${path
    .split('/')
    .filter((identity) => identity)
    .map((part) => {
      const result = /^{([a-z0-9]+)}$/gi.exec(part);

      if (result) {
        return `
    ${camelCase(result[1])},`;
      }
      return `
    '${part}',`;
    })
    .join('')}
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '${API.info.version}',${
      sdkVersion
        ? `
    'X-SDK-Version': '${sdkVersion}',`
        : ''
    }${dereferencedParameters
      .filter((p) => 'header' === p.in)
      .filter((p) => !['X-API-Version', 'X-SDK-Version'].includes(p.name))
      .map(
        (parameter) => `
    '${parameter.name}': ${camelCase(parameter.name)},`,
      )
      .join('')}
  }) as Headers;
  const qs = cleanQuery({${dereferencedParameters
    .filter((p) => 'query' === p.in)
    .map(
      (parameter) => `
    ${parameter.name}: ${camelCase(parameter.name)}${
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (parameter as any).ordered ? '.sort(sortMultipleQuery)' : ''
      },`,
    )
    .join('')}
  });
  const data = ${requestBody ? 'body' : 'undefined'};

  ${getHttpLibResponse(httpLib, API, sdkTypesName, operationId)}
  
}`;
  })
  .join('\n')}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

function formatReponseHeaders(responseHeaders: globalThis.Headers) {
  const headers: Headers = {};
  for (let [key, value] of responseHeaders.entries()) {
      headers[key] = value;
  }
  return headers;
}

export default API;
`;

  return content;
}

function getImports(httpLib: HttpLib) {
  if (httpLib === HttpLib.Axios) {
    return `
import type { AxiosRequestConfig } from 'axios';
import querystring from 'querystring';
import axios from 'axios';
  `;
  } else if (httpLib === HttpLib.Ky) {
    return `
import ky from "ky";
import type { Options as KyOptions } from "ky";
  `;
  } else {
    throw new Error(`This http lib is not implemented yet, ${httpLib}`);
  }
}

function getHttpLibName(httpLib: HttpLib) {
  if (httpLib === HttpLib.Axios) {
    return `Axios`;
  } else if (httpLib === HttpLib.Ky) {
    return `Ky`;
  } else {
    throw new Error(`This http lib is not implemented yet, ${httpLib}`);
  }
}

function getOptionsHttpLib(httpLib: HttpLib) {
  if (httpLib === HttpLib.Axios) {
    return `AxiosRequestConfig`;
  } else if (httpLib === HttpLib.Ky) {
    return `KyOptions`;
  } else {
    throw new Error(`This http lib is not implemented yet, ${httpLib}`);
  }
}

function getHttpLibResponse(
  httpLib: HttpLib,
  API,
  sdkTypesName: string,
  operationId: string,
) {
  if (httpLib === HttpLib.Axios) {
    return ` 
  const response = await axios(Object.assign({
    baseURL: '${API.servers[0].url}',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as ${sdkTypesName}.${
      operationId[0].toUpperCase() + operationId.slice(1)
    }.Output;`;
  } else if (httpLib === HttpLib.Ky) {
    return ` 
  const response = await ky(urlParts.join('/'), {
    prefixUrl: '${API.servers[0].url}',
    method,
    headers: cleanHeaders(headers),
    searchParams: qs.toString(),
    json: data,
    ...options,
  });

  const responseBody = await response.json() as ${sdkTypesName}.${
      operationId[0].toUpperCase() + operationId.slice(1)
    }.Output['body'];
  const responseHeaders = formatReponseHeaders(response.headers);


  return {
    status: response.status,
    headers: responseHeaders,
    body: responseBody,
  } as ${sdkTypesName}.${
      operationId[0].toUpperCase() + operationId.slice(1)
    }.Output;`;
  } else {
    throw new Error(`This http lib is not implemented yet, ${httpLib}`);
  }
}

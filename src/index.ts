/* Architecture Note #1: Generating the SDK

Most SDK from API generator are very opinionated on how the
 users will use it. We wanted to have a very simple API to
 be able to customize it at will.

This file simply eats an OpenAPI file and generate
 the SDK to avoid boilerplate code.

A small article about why and how to do that:
https://insertafter.com/en/blog/considerations_for_generating_api_clients.html
*/

/**
 * @module openapi-ts-sdk-builder
 */

import camelCase from 'camelcase';
import {
  pathItemToOperationMap,
  ensureResolvedObject,
  type OpenAPI,
  type OpenAPIParameter,
  type OpenAPIExtension,
} from 'ya-open-api-types';
import { generateOpenAPITypes, toSource } from 'schema2dts';
import createDebug from 'debug';
import { type ExpressiveJSONSchema } from 'ya-json-schema-types';

const debug = createDebug('openapi-ts-sdk-builder');

const URI_PARAMETERS = ['path', 'query'] as const;
const PARAMETER_TYPE_MAP = {
  path: 'path',
  query: 'query',
  header: 'headers',
  cookie: 'cookies',
} as const;

function upperCamelCase(s: string): string {
  return s[0].toUpperCase() + s.slice(1);
}

async function buildParameterJSDOC(
  API: OpenAPI,
  parameter: OpenAPIParameter<ExpressiveJSONSchema, OpenAPIExtension>,
): Promise<string> {
  const schema =
    'schema' in parameter && parameter.schema
      ? ((await ensureResolvedObject(
          API,
          parameter.schema,
        )) as ExpressiveJSONSchema)
      : undefined;

  if (typeof schema === 'undefined') {
    return '';
  }

  return `
* @param {${
    schema
      ? 'oneOf' in schema && schema.oneOf
        ? [
            ...new Set(
              await Promise.all(
                ((schema.oneOf as ExpressiveJSONSchema[]) || []).map(
                  async (s) => {
                    const dereferencedSchema = (await ensureResolvedObject(
                      API,
                      s,
                    )) as ExpressiveJSONSchema;

                    return dereferencedSchema.type;
                  },
                ),
              ),
            ),
          ].join('|')
        : schema?.type
      : 'any'
  }} ${parameter.required ? `` : `[`}parameters.${camelCase(parameter.name)}${
    parameter.required ? `` : `]`
  }${
    parameter.description
      ? `
 * ${parameter.description}`
      : ''
  }`;
}

/**
 * Build a JS SDK from an OpenAPI file
 *
 * @async
 * @method generateSDKFromOpenAPI
 * @param {string} openAPIContent
 * @param {Object} options
 * @param {string} options.sdkVersion
 * The SDK version
 * @param {string} [options.sdkName]
 * The SDK name (default to API)
 * @param {string[]} [options.ignoredParametersNames]
 * Provide a list of parameters to ignore
 * @param {string[]} [options.undocumentedParametersNames]
 * Provide a list of parameters to keep undocumented
 * @param {Object} [typeOptions]
 * Options to be passed to the type generator
 * @return {Promise<string>} The SDK JS code
 */
export async function generateSDKFromOpenAPI(
  openAPIContent: string,
  {
    sdkVersion,
    sdkName = 'API',
    ignoredParametersNames = [],
    undocumentedParametersNames = [],
  }: {
    sdkVersion: string;
    sdkName?: string;
    ignoredParametersNames?: string[];
    undocumentedParametersNames?: string[];
  },
  typeOptions: Parameters<typeof generateOpenAPITypes>[1] = {
    exportNamespaces: true,
    generateRealEnums: true,
    tuplesFromFixedArraysLengthLimit: 2,
  },
): Promise<string> {
  const adaptedTypeOptions = {
    ...typeOptions,
    baseName: sdkName + 'Types',
  };
  const API = JSON.parse(openAPIContent) as OpenAPI;

  const oOperations = {};

  for (const [path, pathItem] of Object.entries(API.paths || {})) {
    for (const [method, operation] of Object.entries(
      pathItemToOperationMap(pathItem || {}),
    )) {
      if (!operation.operationId) {
        debug(
          '‚ùå - Operations without operationId are not supported!',
          operation,
        );
        continue;
      }

      oOperations[operation.operationId] = {
        path,
        method,
        operation,
      };
    }
  }

  let content = `// WARNING: This file is automatically generated
// by the 'openapi-ts-sed-builder' module do not
// change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;
export interface RouteTypeDefinition {
  requestBody?: unknown;
  responses?: {
    default?: {
      headers?: unknown;
      body?: unknown;
    };
    [key: number]: {
      headers?: unknown;
      body?: unknown;
    };
  };
  parameters?: {
    path?: object;
    query?: object;
    headers?: object;
    cookies?: object;
  };
}
export type RouteTypedHandler<
  T extends RouteTypeDefinition,
  O extends object = object,
> = (
  parameters: T["parameters"] &
    (T["requestBody"] extends object | string | number | boolean
      ? {
          body: T["requestBody"];
          options?: O;
        }
      : { options?: O })
) => Promise<
  {
    [Status in keyof T["responses"]]: {
      status: Status extends number ? Status : number;
    } & T["responses"][Status];
  }[keyof T["responses"]]
>;

${toSource(await generateOpenAPITypes(API, adaptedTypeOptions))}

/**
 * ${API.info.description}
 * @module API
 * @version ${API.info.version}
 */
const API = {${Object.keys(oOperations)
    .map(
      (operationId) => `
  ${operationId},`,
    )
    .join('')}
};

export const APIURIBuilders = {${Object.keys(oOperations)
    .map(
      (operationId) => `
  ${operationId}: build${upperCamelCase(operationId)}URI,`,
    )
    .join('')}
};

export const APIMethods = {${Object.keys(oOperations)
    .map(
      (operationId) => `
  ${operationId}: '${oOperations[operationId].method}',`,
    )
    .join('')}
} as const;

export const APIStatuses = {${Object.keys(oOperations)
    .map(
      (operationId) => `
  ${operationId}: [${Object.keys(
    oOperations[operationId].operation.responses || { default: '' },
  )
    .map((code) => (code !== 'default' ? parseInt(code, 10) : `"${code}"`))
    .join(', ')}],`,
    )
    .join('')}
} as const;

export const APIInputBuilders = {`;

  content += `${Object.keys(oOperations)
    .map(
      (operationId) => `
  ${operationId}: build${upperCamelCase(operationId)}Input,`,
    )
    .join('')}
};`;

  for (const operationId of Object.keys(oOperations)) {
    const { path, operation } = oOperations[operationId];
    const { parameters, requestBody } = operation;
    const dereferencedParameters: OpenAPIParameter<
      ExpressiveJSONSchema,
      OpenAPIExtension
    >[] = [];

    for (const parameter of parameters || []) {
      const dereferencedParameter = await ensureResolvedObject(API, parameter);

      if (ignoredParametersNames.includes(dereferencedParameter.name)) {
        continue;
      }

      dereferencedParameters.push(dereferencedParameter);
    }

    const uriParameters = dereferencedParameters.filter((parameter) =>
      (URI_PARAMETERS as unknown as string[]).includes(parameter.in),
    );
    const uriParametersTypes = URI_PARAMETERS.filter((type) =>
      uriParameters.some((parameter) => parameter.in === type),
    );
    const nonURIParameters = dereferencedParameters.filter(
      (parameter) =>
        !(URI_PARAMETERS as unknown as string[]).includes(parameter.in),
    );
    const parametersTypes = [
      ...new Set(dereferencedParameters.map((parameter) => parameter.in)),
    ];

    content += `

/**
 * Build the "${operation.operationId}" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)${(
   await Promise.all(
     uriParameters
       .filter((p) => !undocumentedParametersNames.includes(p.name))
       .map(buildParameterJSDOC.bind(null, API)),
   )
 ).join(',')}
 */
function build${upperCamelCase(operationId)}URI(`;

    if (uriParameters.length) {
      content += `
  { ${uriParametersTypes.join(', ')} } : ${
    uriParameters.length
      ? `Pick<operations["${operationId}"]["parameters"], ${uriParametersTypes.map((type) => `'${type}'`).join(' | ')}>`
      : 'Record<string, never>'
  }`;
    } else {
      content += `
  _: unknown`;
    }

    content += `,
) : URIData {`;

    for (const parameter of uriParameters) {
      if (parameter.required) {
        content += `
  if(${PARAMETER_TYPE_MAP[parameter.in]}['${parameter.name}'] == null) {
    throw new Error('Missing required parameter: "${PARAMETER_TYPE_MAP[parameter.in]}[${parameter.name}]", value : ' +  ${PARAMETER_TYPE_MAP[parameter.in]}['${parameter.name}']);
  }`;
      }
    }

    content += `

  const __pathParts = [${path
    .split('/')
    .filter((identity) => identity)
    .map((part) => {
      const result = /^{([a-z0-9_]+)}$/gi.exec(part);

      if (result) {
        return `
    path['${result[1]}'],`;
      }
      return `
    '${part}',`;
    })
    .join('')}
  ];
  const __qs = cleanQuery({${dereferencedParameters
    .filter((p) => 'query' === p.in)
    .map(
      (parameter) => `
    ${parameter.name}: query['${parameter.name}']${
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (parameter as any).ordered ? '.sort(sortMultipleQuery)' : ''
    },`,
    )
    .join('')}
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}`;

    content += `

/**
 * Build all the "${operation.operationId}" parameters
 * @return {Object}
 * The object describing the built parameters${
   requestBody
     ? `
 * @param {Object} body
 * The request body`
     : ''
 }
 * @param {Object} parameters
 * The parameters provided to build them (destructured)${(
   await Promise.all(
     dereferencedParameters
       .filter((p) => !undocumentedParametersNames.includes(p.name))
       .map(buildParameterJSDOC.bind(null, API)),
   )
 ).join(',')}
 */`;

    content += `

function build${upperCamelCase(operationId)}Input(${
      requestBody || (dereferencedParameters && dereferencedParameters.length)
        ? `
  {${
    requestBody
      ? `
    body,`
      : ''
  }${parametersTypes
    .map(
      (type) => `
    ${PARAMETER_TYPE_MAP[type]},`,
    )
    .join('')}
  }:${
    requestBody
      ? `
    { body?: operations["${operationId}"]["requestBody"] } &
   `
      : ''
  } Parameters<RouteTypedHandler<operations["${operationId}"]>>[0]`
        : `
  _: unknown`
    },
) {

${nonURIParameters
  .map((parameter) =>
    parameter.required
      ? `
  if( ${PARAMETER_TYPE_MAP[parameter.in]}['${parameter.name}'] == null) {
    throw new Error('Missing required parameter : "${PARAMETER_TYPE_MAP[parameter.in]}[${parameter.name}]", value : ' +  ${PARAMETER_TYPE_MAP[parameter.in]}['${parameter.name}']);
  }
`
      : '',
  )
  .join('')}

  const __method = APIMethods.${operationId};
  const __uriData = build${upperCamelCase(operationId)}URI({ ${uriParametersTypes.join(', ')} });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '${API.info.version}',${
        sdkVersion
          ? `
      'X-SDK-Version': '${sdkVersion}',`
          : ''
      }${(
        await Promise.all(
          dereferencedParameters
            .filter((p) => 'header' === p.in)
            .filter((p) => !['X-API-Version', 'X-SDK-Version'].includes(p.name))
            .map(async (parameter) => {
              const schema =
                'schema' in parameter
                  ? ((await ensureResolvedObject(
                      API,
                      parameter.schema,
                    )) as ExpressiveJSONSchema)
                  : undefined;

              return `
      '${parameter.name}': headers['${parameter.name}']${
        schema?.type !== 'string' ? '.toString()' : ''
      } as string,`;
            }),
        )
      ).join('')}
    }),
    body: ${requestBody ? 'body' : 'undefined'},
  } as HTTPRequest<${
    requestBody
      ? `
    operations["${operationId}"]["requestBody"]
  `
      : 'undefined'
  }>;
}`;
    content += `

/**
 * ${operation.summary}
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)${
   requestBody
     ? `
 * @param {Object} parameters.body
 * The request body`
     : ''
 }${(
   await Promise.all(
     dereferencedParameters
       .filter((p) => !undocumentedParametersNames.includes(p.name))
       .map(buildParameterJSDOC.bind(null, API)),
   )
 ).join(',')}
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function ${operationId}<O>(
  executeRequest: RequestExecutor<O>,${
    requestBody || (dereferencedParameters && dereferencedParameters.length)
      ? `
  {${
    requestBody
      ? `
    body,`
      : ''
  }${parametersTypes
    .map(
      (type) => `
    ${PARAMETER_TYPE_MAP[type]},`,
    )
    .join('')}
  }:${
    requestBody
      ? `
    { body?: operations["${operationId}"]["requestBody"] } &
   `
      : ''
  } Parameters<RouteTypedHandler<operations["${operationId}"]>>[0]`
      : `
  _: unknown`
  },
  options: O,
) {
  const httpRequest = build${upperCamelCase(operationId)}Input({${
    requestBody
      ? `
    body,`
      : ''
  }${parametersTypes
    .map(
      (type) => `
    ${PARAMETER_TYPE_MAP[type]},`,
    )
    .join('')}
  });

  return (await executeRequest(
    httpRequest,
    "${operationId}",
    options,
  ))${requestBody ? ` as HTTPResponse<operations["${operationId}"]["requestBody"]>` : ''};
}`;
  }

  content += `

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
`;

  return content;
}

// Code duplicated from https://github.com/nfroidure/whook/blob/master/packages/whook-http-router/src/libs/openAPIUtils.ts
// TODO: Use it back when it gets strict TS ready

export const OPEN_API_METHODS = [
  'options',
  'head',
  'get',
  'put',
  'post',
  'patch',
  'delete',
  'trace',
];

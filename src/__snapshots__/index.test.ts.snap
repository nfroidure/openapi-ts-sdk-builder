// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateSDKFromOpenAPI should work 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;

export namespace APITypes {
    export namespace GetOpenAPI {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getOpenAPIResponse200<200>;
        }
    }
    export namespace GetPing {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getPingResponse200<200>;
        }
    }
    export namespace GetDelay {
        export type Output = Responses.$204;
        export type Input = {
            readonly duration: Parameters.Duration;
            readonly cookie?: Parameters.Cookie;
            readonly xApplicationVersion?: Parameters.XApplicationVersion;
        };
        export namespace Responses {
            export type $204 = Components.Responses.getDelayResponse204<204>;
        }
        export namespace Parameters {
            export type Duration = Components.Parameters.GetDelay0;
            export type Cookie = Components.Parameters.GetDelay1;
            export type XApplicationVersion = Components.Parameters.GetDelay2;
        }
    }
    export namespace GetDiagnostic {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getDiagnosticResponse200<200>;
        }
    }
    export namespace GetTime {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getTimeResponse200<200>;
        }
    }
    export namespace PutEcho {
        export type Body = Components.RequestBodies.PutEchoRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.putEchoResponse200<200>;
        }
    }
}
export namespace Components {
    export namespace RequestBodies {
        export type PutEchoRequestBody = Components.Schemas.RequestBodiesputEchoRequestBodyBody0;
    }
    export namespace Parameters {
        export type GetDelay0 = number;
        export type GetDelay1 = string;
        export type GetDelay2 = string;
    }
    export namespace Responses {
        export type getDelayResponse204<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type getOpenAPIResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetOpenAPIResponse200Body0;
        };
        export type getPingResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetPingResponse200Body0;
        };
        export type getDiagnosticResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetDiagnosticResponse200Body0;
        };
        export type getTimeResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetTimeResponse200Body0;
        };
        export type putEchoResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesputEchoResponse200Body0;
        };
    }
    export namespace Schemas {
        export type RequestBodiesputEchoRequestBodyBody0 = {
            echo: string;
        };
        export type ResponsesgetOpenAPIResponse200Body0 = {};
        export type ResponsesgetPingResponse200Body0 = {
            pong?: "pong";
        };
        export type ResponsesgetDiagnosticResponse200Body0 = {
            [pattern: string]: unknown;
        };
        export type ResponsesgetTimeResponse200Body0 = {
            currentDate?: string;
        };
        export type ResponsesputEchoResponse200Body0 = {
            echo: string;
        };
    }
}

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getOpenAPI,
  getPing,
  getDelay,
  getDiagnostic,
  getTime,
  putEcho,
};

export const APIURIBuilders = {
  getOpenAPI: buildGetOpenAPIURI,
  getPing: buildGetPingURI,
  getDelay: buildGetDelayURI,
  getDiagnostic: buildGetDiagnosticURI,
  getTime: buildGetTimeURI,
  putEcho: buildPutEchoURI,
};

export const APIMethods = {
  getOpenAPI: 'get',
  getPing: 'get',
  getDelay: 'get',
  getDiagnostic: 'get',
  getTime: 'get',
  putEcho: 'put',
} as const;

export const APIStatuses = {
  getOpenAPI: [200],
  getPing: [200],
  getDelay: [204],
  getDiagnostic: [200],
  getTime: [200],
  putEcho: [200],
} as const;

export const APIInputBuilders = {
  getOpenAPI: buildGetOpenAPIInput,
  getPing: buildGetPingInput,
  getDelay: buildGetDelayInput,
  getDiagnostic: buildGetDiagnosticInput,
  getTime: buildGetTimeInput,
  putEcho: buildPutEchoInput,
};


/**
 * Build the "getOpenAPI" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetOpenAPIURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'openAPI',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getOpenAPI" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildGetOpenAPIInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getOpenAPI;
  const __uriData = buildGetOpenAPIURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Get API documentation.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getOpenAPI<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<APITypes.GetOpenAPI.Output>> {
  const httpRequest = buildGetOpenAPIInput({
  });

  return (await executeRequest(
    httpRequest,
    "getOpenAPI",
    options,
  )) as APITypes.GetOpenAPI.Output;
}


/**
 * Build the "getPing" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetPingURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'ping',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getPing" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildGetPingInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getPing;
  const __uriData = buildGetPingURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Checks API's availability.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getPing<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<APITypes.GetPing.Output>> {
  const httpRequest = buildGetPingInput({
  });

  return (await executeRequest(
    httpRequest,
    "getPing",
    options,
  )) as APITypes.GetPing.Output;
}


/**
 * Build the "getDelay" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 */
function buildGetDelayURI(
  {
    duration,
  } : Pick<APITypes.GetDelay.Input,
    'duration'
      >,
) : URIData {
  if(duration == null) {
    throw new Error('Missing required parameter: duration. Value : ' +  duration);
  }

  const __pathParts = [
    'delay',
  ];
  const __qs = cleanQuery({
    duration: duration,
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getDelay" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 */
function buildGetDelayInput(
  {
    duration,
    xApplicationVersion,
  } : APITypes.GetDelay.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getDelay;
  const __uriData = buildGetDelayURI({
    duration,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
      'X-Application-Version': xApplicationVersion,
    }),
    body: undefined,
  };
}

/**
 * Answer after a given delay.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getDelay<O>(
  executeRequest: RequestExecutor<O>,
  {
    duration,
    xApplicationVersion,
  } : APITypes.GetDelay.Input,
  options: O,
) : Promise<Writeable<APITypes.GetDelay.Output>> {
  const httpRequest = buildGetDelayInput({
    duration,
    xApplicationVersion,
  });

  return (await executeRequest(
    httpRequest,
    "getDelay",
    options,
  )) as APITypes.GetDelay.Output;
}


/**
 * Build the "getDiagnostic" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetDiagnosticURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'diag',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getDiagnostic" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildGetDiagnosticInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getDiagnostic;
  const __uriData = buildGetDiagnosticURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Returns current API's transactions.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getDiagnostic<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<APITypes.GetDiagnostic.Output>> {
  const httpRequest = buildGetDiagnosticInput({
  });

  return (await executeRequest(
    httpRequest,
    "getDiagnostic",
    options,
  )) as APITypes.GetDiagnostic.Output;
}


/**
 * Build the "getTime" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetTimeURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'time',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getTime" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildGetTimeInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getTime;
  const __uriData = buildGetTimeURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Get API internal clock date.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getTime<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<APITypes.GetTime.Output>> {
  const httpRequest = buildGetTimeInput({
  });

  return (await executeRequest(
    httpRequest,
    "getTime",
    options,
  )) as APITypes.GetTime.Output;
}


/**
 * Build the "putEcho" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildPutEchoURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'echo',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "putEcho" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildPutEchoInput(
  {
    body,
  } : APITypes.PutEcho.Input,
) : HTTPRequest<APITypes.PutEcho.Input['body']> {



  const __method = APIMethods.putEcho;
  const __uriData = buildPutEchoURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Echoes what it takes.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function putEcho<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  } : APITypes.PutEcho.Input,
  options: O,
) : Promise<Writeable<APITypes.PutEcho.Output>> {
  const httpRequest = buildPutEchoInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "putEcho",
    options,
  )) as APITypes.PutEcho.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with Pet Store 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;

export namespace APITypes {
    export namespace UpdatePet {
        export type Body = Components.RequestBodies.Pet;
        export type Output = Responses.$400 | Responses.$404 | Responses.$405;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $400 = Components.Responses.updatePetResponse400<400>;
            export type $404 = Components.Responses.updatePetResponse404<404>;
            export type $405 = Components.Responses.updatePetResponse405<405>;
        }
    }
    export namespace AddPet {
        export type Body = Components.RequestBodies.Pet;
        export type Output = Responses.$405;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $405 = Components.Responses.addPetResponse405<405>;
        }
    }
    export namespace FindPetsByStatus {
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly status: Parameters.Status;
        };
        export namespace Responses {
            export type $200 = Components.Responses.findPetsByStatusResponse200<200>;
            export type $400 = Components.Responses.findPetsByStatusResponse400<400>;
        }
        export namespace Parameters {
            export type Status = Components.Parameters.FindPetsByStatus0;
        }
    }
    export namespace FindPetsByTags {
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly tags: Parameters.Tags;
        };
        export namespace Responses {
            export type $200 = Components.Responses.findPetsByTagsResponse200<200>;
            export type $400 = Components.Responses.findPetsByTagsResponse400<400>;
        }
        export namespace Parameters {
            export type Tags = Components.Parameters.FindPetsByTags0;
        }
    }
    export namespace GetPetById {
        export type Output = Responses.$200 | Responses.$400 | Responses.$404;
        export type Input = {
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $200 = Components.Responses.getPetByIdResponse200<200>;
            export type $400 = Components.Responses.getPetByIdResponse400<400>;
            export type $404 = Components.Responses.getPetByIdResponse404<404>;
        }
        export namespace Parameters {
            export type PetId = Components.Parameters.GetPetById0;
        }
    }
    export namespace UpdatePetWithForm {
        export type Body = Components.RequestBodies.UpdatePetWithFormRequestBody;
        export type Output = Responses.$405;
        export type Input = {
            readonly body?: Body;
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $405 = Components.Responses.updatePetWithFormResponse405<405>;
        }
        export namespace Parameters {
            export type PetId = Components.Parameters.UpdatePetWithForm0;
        }
    }
    export namespace DeletePet {
        export type Output = Responses.$400;
        export type Input = {
            readonly apiKey?: Parameters.ApiKey;
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $400 = Components.Responses.deletePetResponse400<400>;
        }
        export namespace Parameters {
            export type ApiKey = Components.Parameters.DeletePet0;
            export type PetId = Components.Parameters.DeletePet1;
        }
    }
    export namespace UploadFile {
        export type Body = Components.RequestBodies.UploadFileRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $200 = Components.Responses.uploadFileResponse200<200>;
        }
        export namespace Parameters {
            export type PetId = Components.Parameters.UploadFile0;
        }
    }
    export namespace GetInventory {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getInventoryResponse200<200>;
        }
    }
    export namespace PlaceOrder {
        export type Body = Components.RequestBodies.PlaceOrderRequestBody;
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.placeOrderResponse200<200>;
            export type $400 = Components.Responses.placeOrderResponse400<400>;
        }
    }
    export namespace GetOrderById {
        export type Output = Responses.$200 | Responses.$400 | Responses.$404;
        export type Input = {
            readonly orderId: Parameters.OrderId;
        };
        export namespace Responses {
            export type $200 = Components.Responses.getOrderByIdResponse200<200>;
            export type $400 = Components.Responses.getOrderByIdResponse400<400>;
            export type $404 = Components.Responses.getOrderByIdResponse404<404>;
        }
        export namespace Parameters {
            export type OrderId = Components.Parameters.GetOrderById0;
        }
    }
    export namespace DeleteOrder {
        export type Output = Responses.$400 | Responses.$404;
        export type Input = {
            readonly orderId: Parameters.OrderId;
        };
        export namespace Responses {
            export type $400 = Components.Responses.deleteOrderResponse400<400>;
            export type $404 = Components.Responses.deleteOrderResponse404<404>;
        }
        export namespace Parameters {
            export type OrderId = Components.Parameters.DeleteOrder0;
        }
    }
    export namespace CreateUser {
        export type Body = Components.RequestBodies.CreateUserRequestBody;
        export type Output = Responses.$default;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $default = Components.Responses.createUserResponsedefault<number>;
        }
    }
    export namespace CreateUsersWithArrayInput {
        export type Body = Components.RequestBodies.UserArray;
        export type Output = Responses.$default;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $default = Components.Responses.createUsersWithArrayInputResponsedefault<number>;
        }
    }
    export namespace CreateUsersWithListInput {
        export type Body = Components.RequestBodies.UserArray;
        export type Output = Responses.$default;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $default = Components.Responses.createUsersWithListInputResponsedefault<number>;
        }
    }
    export namespace LoginUser {
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly username: Parameters.Username;
            readonly password: Parameters.Password;
        };
        export namespace Responses {
            export type $200 = Components.Responses.loginUserResponse200<200>;
            export type $400 = Components.Responses.loginUserResponse400<400>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.LoginUser0;
            export type Password = Components.Parameters.LoginUser1;
        }
    }
    export namespace LogoutUser {
        export type Output = Responses.$default;
        export type Input = {};
        export namespace Responses {
            export type $default = Components.Responses.logoutUserResponsedefault<number>;
        }
    }
    export namespace GetUserByName {
        export type Output = Responses.$200 | Responses.$400 | Responses.$404;
        export type Input = {
            readonly username: Parameters.Username;
        };
        export namespace Responses {
            export type $200 = Components.Responses.getUserByNameResponse200<200>;
            export type $400 = Components.Responses.getUserByNameResponse400<400>;
            export type $404 = Components.Responses.getUserByNameResponse404<404>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.GetUserByName0;
        }
    }
    export namespace UpdateUser {
        export type Body = Components.RequestBodies.UpdateUserRequestBody;
        export type Output = Responses.$400 | Responses.$404;
        export type Input = {
            readonly body: Body;
            readonly username: Parameters.Username;
        };
        export namespace Responses {
            export type $400 = Components.Responses.updateUserResponse400<400>;
            export type $404 = Components.Responses.updateUserResponse404<404>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.UpdateUser0;
        }
    }
    export namespace DeleteUser {
        export type Output = Responses.$400 | Responses.$404;
        export type Input = {
            readonly username: Parameters.Username;
        };
        export namespace Responses {
            export type $400 = Components.Responses.deleteUserResponse400<400>;
            export type $404 = Components.Responses.deleteUserResponse404<404>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.DeleteUser0;
        }
    }
}
export namespace Components {
    export namespace RequestBodies {
        export type UserArray = Components.Schemas.RequestBodiesUserArrayBody0;
        export type Pet = Components.Schemas.Pet | Components.Schemas.Pet;
        export type UpdatePetWithFormRequestBody = Components.Schemas.Body;
        export type UploadFileRequestBody = Components.Schemas.Body1;
        export type PlaceOrderRequestBody = Components.Schemas.Order;
        export type CreateUserRequestBody = Components.Schemas.User;
        export type UpdateUserRequestBody = Components.Schemas.User;
    }
    export namespace Parameters {
        export type GetPetById0 = number;
        export type UpdatePetWithForm0 = number;
        export type DeletePet0 = string;
        export type DeletePet1 = number;
        export type UploadFile0 = number;
        export type GetOrderById0 = number;
        export type DeleteOrder0 = string;
        export type LoginUser0 = string;
        export type LoginUser1 = string;
        export type GetUserByName0 = string;
        export type UpdateUser0 = string;
        export type DeleteUser0 = string;
        export type FindPetsByStatus0 = ("available" | "pending" | "sold")[];
        export type FindPetsByTags0 = string[];
    }
    export namespace Responses {
        export type updatePetResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type updatePetResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type updatePetResponse405<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type addPetResponse405<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type findPetsByStatusResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type findPetsByTagsResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type getPetByIdResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type getPetByIdResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type updatePetWithFormResponse405<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type deletePetResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type placeOrderResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type getOrderByIdResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type getOrderByIdResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type deleteOrderResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type deleteOrderResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type createUserResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type createUsersWithArrayInputResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type createUsersWithListInputResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type loginUserResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type logoutUserResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type getUserByNameResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type getUserByNameResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type updateUserResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type updateUserResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type deleteUserResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type deleteUserResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type findPetsByStatusResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesfindPetsByStatusResponse200Body0 | Components.Schemas.ResponsesfindPetsByStatusResponse200Body1;
        };
        export type findPetsByTagsResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesfindPetsByTagsResponse200Body0 | Components.Schemas.ResponsesfindPetsByTagsResponse200Body1;
        };
        export type getPetByIdResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.Pet | Components.Schemas.Pet;
        };
        export type uploadFileResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ApiResponse;
        };
        export type getInventoryResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetInventoryResponse200Body0;
        };
        export type placeOrderResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.Order | Components.Schemas.Order;
        };
        export type getOrderByIdResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.Order | Components.Schemas.Order;
        };
        export type getUserByNameResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.User | Components.Schemas.User;
        };
        export type loginUserResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly "x-rate-limit"?: Components.Headers.LoginUserResponse200HeadersXRateLimit;
                readonly "x-expires-after"?: Components.Headers.LoginUserResponse200HeadersXExpiresAfter;
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesloginUserResponse200Body0 | Components.Schemas.ResponsesloginUserResponse200Body1;
        };
    }
    export namespace Headers {
        export type LoginUserResponse200HeadersXRateLimit = number;
        export type LoginUserResponse200HeadersXExpiresAfter = string;
    }
    export namespace Schemas {
        export type RequestBodiesUserArrayBody0 = Components.Schemas.User[];
        export type Pet = {
            id?: number;
            category?: Components.Schemas.Category;
            name: string;
            photoUrls: string[];
            tags?: Components.Schemas.Tag[];
            status?: Enums.Status;
        };
        export type Body = {
            name?: string;
            status?: string;
        };
        export type Body1 = {
            additionalMetadata?: string;
            file?: string;
        };
        export type Order = {
            id?: number;
            petId?: number;
            quantity?: number;
            shipDate?: string;
            status?: Enums.Status;
            complete?: boolean;
        };
        export type User = {
            id?: number;
            username?: string;
            firstName?: string;
            lastName?: string;
            email?: string;
            password?: string;
            phone?: string;
            userStatus?: number;
        };
        export type ResponsesfindPetsByStatusResponse200Body0 = Components.Schemas.Pet[];
        export type ResponsesfindPetsByStatusResponse200Body1 = Components.Schemas.Pet[];
        export type ResponsesfindPetsByTagsResponse200Body0 = Components.Schemas.Pet[];
        export type ResponsesfindPetsByTagsResponse200Body1 = Components.Schemas.Pet[];
        export type ApiResponse = {
            code?: number;
            type?: string;
            message?: string;
        };
        export type ResponsesgetInventoryResponse200Body0 = {
            [pattern: string]: unknown;
        };
        export type ResponsesloginUserResponse200Body0 = string;
        export type ResponsesloginUserResponse200Body1 = string;
        export type Category = {
            id?: number;
            name?: string;
        };
        export type Tag = {
            id?: number;
            name?: string;
        };
    }
}
export namespace Enums {
    export enum Status {
        Available = "available",
        Pending = "pending",
        Sold = "sold"
    }
    export enum Status {
        Placed = "placed",
        Approved = "approved",
        Delivered = "delivered"
    }
}

/**
 * This is a sample server Petstore server. For this sample, you can use the api key \`special-key\` to test the authorization filters. For OAuth2 flow, you may use \`user\` as both username and password when asked to login.
 * @module API
 * @version 1.0.0
 */
const API = {
  updatePet,
  addPet,
  findPetsByStatus,
  findPetsByTags,
  getPetById,
  updatePetWithForm,
  deletePet,
  uploadFile,
  getInventory,
  placeOrder,
  getOrderById,
  deleteOrder,
  createUser,
  createUsersWithArrayInput,
  createUsersWithListInput,
  loginUser,
  logoutUser,
  getUserByName,
  updateUser,
  deleteUser,
};

export const APIURIBuilders = {
  updatePet: buildUpdatePetURI,
  addPet: buildAddPetURI,
  findPetsByStatus: buildFindPetsByStatusURI,
  findPetsByTags: buildFindPetsByTagsURI,
  getPetById: buildGetPetByIdURI,
  updatePetWithForm: buildUpdatePetWithFormURI,
  deletePet: buildDeletePetURI,
  uploadFile: buildUploadFileURI,
  getInventory: buildGetInventoryURI,
  placeOrder: buildPlaceOrderURI,
  getOrderById: buildGetOrderByIdURI,
  deleteOrder: buildDeleteOrderURI,
  createUser: buildCreateUserURI,
  createUsersWithArrayInput: buildCreateUsersWithArrayInputURI,
  createUsersWithListInput: buildCreateUsersWithListInputURI,
  loginUser: buildLoginUserURI,
  logoutUser: buildLogoutUserURI,
  getUserByName: buildGetUserByNameURI,
  updateUser: buildUpdateUserURI,
  deleteUser: buildDeleteUserURI,
};

export const APIMethods = {
  updatePet: 'put',
  addPet: 'post',
  findPetsByStatus: 'get',
  findPetsByTags: 'get',
  getPetById: 'get',
  updatePetWithForm: 'post',
  deletePet: 'delete',
  uploadFile: 'post',
  getInventory: 'get',
  placeOrder: 'post',
  getOrderById: 'get',
  deleteOrder: 'delete',
  createUser: 'post',
  createUsersWithArrayInput: 'post',
  createUsersWithListInput: 'post',
  loginUser: 'get',
  logoutUser: 'get',
  getUserByName: 'get',
  updateUser: 'put',
  deleteUser: 'delete',
} as const;

export const APIStatuses = {
  updatePet: [400, 404, 405],
  addPet: [405],
  findPetsByStatus: [200, 400],
  findPetsByTags: [200, 400],
  getPetById: [200, 400, 404],
  updatePetWithForm: [405],
  deletePet: [400],
  uploadFile: [200],
  getInventory: [200],
  placeOrder: [200, 400],
  getOrderById: [200, 400, 404],
  deleteOrder: [400, 404],
  createUser: ["default"],
  createUsersWithArrayInput: ["default"],
  createUsersWithListInput: ["default"],
  loginUser: [200, 400],
  logoutUser: ["default"],
  getUserByName: [200, 400, 404],
  updateUser: [400, 404],
  deleteUser: [400, 404],
} as const;

export const APIInputBuilders = {
  updatePet: buildUpdatePetInput,
  addPet: buildAddPetInput,
  findPetsByStatus: buildFindPetsByStatusInput,
  findPetsByTags: buildFindPetsByTagsInput,
  getPetById: buildGetPetByIdInput,
  updatePetWithForm: buildUpdatePetWithFormInput,
  deletePet: buildDeletePetInput,
  uploadFile: buildUploadFileInput,
  getInventory: buildGetInventoryInput,
  placeOrder: buildPlaceOrderInput,
  getOrderById: buildGetOrderByIdInput,
  deleteOrder: buildDeleteOrderInput,
  createUser: buildCreateUserInput,
  createUsersWithArrayInput: buildCreateUsersWithArrayInputInput,
  createUsersWithListInput: buildCreateUsersWithListInputInput,
  loginUser: buildLoginUserInput,
  logoutUser: buildLogoutUserInput,
  getUserByName: buildGetUserByNameInput,
  updateUser: buildUpdateUserInput,
  deleteUser: buildDeleteUserInput,
};


/**
 * Build the "updatePet" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildUpdatePetURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'pet',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "updatePet" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildUpdatePetInput(
  {
    body,
  } : APITypes.UpdatePet.Input,
) : HTTPRequest<APITypes.UpdatePet.Input['body']> {



  const __method = APIMethods.updatePet;
  const __uriData = buildUpdatePetURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Update an existing pet
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function updatePet<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  } : APITypes.UpdatePet.Input,
  options: O,
) : Promise<Writeable<APITypes.UpdatePet.Output>> {
  const httpRequest = buildUpdatePetInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "updatePet",
    options,
  )) as APITypes.UpdatePet.Output;
}


/**
 * Build the "addPet" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildAddPetURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'pet',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "addPet" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildAddPetInput(
  {
    body,
  } : APITypes.AddPet.Input,
) : HTTPRequest<APITypes.AddPet.Input['body']> {



  const __method = APIMethods.addPet;
  const __uriData = buildAddPetURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Add a new pet to the store
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function addPet<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  } : APITypes.AddPet.Input,
  options: O,
) : Promise<Writeable<APITypes.AddPet.Output>> {
  const httpRequest = buildAddPetInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "addPet",
    options,
  )) as APITypes.AddPet.Output;
}


/**
 * Build the "findPetsByStatus" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {array} parameters.status
 * Status values that need to be considered for filter
 */
function buildFindPetsByStatusURI(
  {
    status,
  } : Pick<APITypes.FindPetsByStatus.Input,
    'status'
      >,
) : URIData {
  if(status == null) {
    throw new Error('Missing required parameter: status. Value : ' +  status);
  }

  const __pathParts = [
    'pet',
    'findByStatus',
  ];
  const __qs = cleanQuery({
    status: status,
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "findPetsByStatus" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.status
 * Status values that need to be considered for filter
 */
function buildFindPetsByStatusInput(
  {
    status,
  } : APITypes.FindPetsByStatus.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.findPetsByStatus;
  const __uriData = buildFindPetsByStatusURI({
    status,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Finds Pets by status
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.status
 * Status values that need to be considered for filter
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function findPetsByStatus<O>(
  executeRequest: RequestExecutor<O>,
  {
    status,
  } : APITypes.FindPetsByStatus.Input,
  options: O,
) : Promise<Writeable<APITypes.FindPetsByStatus.Output>> {
  const httpRequest = buildFindPetsByStatusInput({
    status,
  });

  return (await executeRequest(
    httpRequest,
    "findPetsByStatus",
    options,
  )) as APITypes.FindPetsByStatus.Output;
}


/**
 * Build the "findPetsByTags" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {array} parameters.tags
 * Tags to filter by
 */
function buildFindPetsByTagsURI(
  {
    tags,
  } : Pick<APITypes.FindPetsByTags.Input,
    'tags'
      >,
) : URIData {
  if(tags == null) {
    throw new Error('Missing required parameter: tags. Value : ' +  tags);
  }

  const __pathParts = [
    'pet',
    'findByTags',
  ];
  const __qs = cleanQuery({
    tags: tags,
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "findPetsByTags" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.tags
 * Tags to filter by
 */
function buildFindPetsByTagsInput(
  {
    tags,
  } : APITypes.FindPetsByTags.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.findPetsByTags;
  const __uriData = buildFindPetsByTagsURI({
    tags,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Finds Pets by tags
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.tags
 * Tags to filter by
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function findPetsByTags<O>(
  executeRequest: RequestExecutor<O>,
  {
    tags,
  } : APITypes.FindPetsByTags.Input,
  options: O,
) : Promise<Writeable<APITypes.FindPetsByTags.Output>> {
  const httpRequest = buildFindPetsByTagsInput({
    tags,
  });

  return (await executeRequest(
    httpRequest,
    "findPetsByTags",
    options,
  )) as APITypes.FindPetsByTags.Output;
}


/**
 * Build the "getPetById" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * ID of pet to return
 */
function buildGetPetByIdURI(
  {
    petId,
  } : Pick<APITypes.GetPetById.Input,
    'petId'
      >,
) : URIData {
  if(petId == null) {
    throw new Error('Missing required parameter: petId. Value : ' +  petId);
  }

  const __pathParts = [
    'pet',
    petId,
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getPetById" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet to return
 */
function buildGetPetByIdInput(
  {
    petId,
  } : APITypes.GetPetById.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getPetById;
  const __uriData = buildGetPetByIdURI({
    petId,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Find pet by ID
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet to return
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getPetById<O>(
  executeRequest: RequestExecutor<O>,
  {
    petId,
  } : APITypes.GetPetById.Input,
  options: O,
) : Promise<Writeable<APITypes.GetPetById.Output>> {
  const httpRequest = buildGetPetByIdInput({
    petId,
  });

  return (await executeRequest(
    httpRequest,
    "getPetById",
    options,
  )) as APITypes.GetPetById.Output;
}


/**
 * Build the "updatePetWithForm" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * ID of pet that needs to be updated
 */
function buildUpdatePetWithFormURI(
  {
    petId,
  } : Pick<APITypes.UpdatePetWithForm.Input,
    'petId'
      >,
) : URIData {
  if(petId == null) {
    throw new Error('Missing required parameter: petId. Value : ' +  petId);
  }

  const __pathParts = [
    'pet',
    petId,
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "updatePetWithForm" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet that needs to be updated
 */
function buildUpdatePetWithFormInput(
  {
    body,
    petId,
  } : APITypes.UpdatePetWithForm.Input,
) : HTTPRequest<APITypes.UpdatePetWithForm.Input['body']> {



  const __method = APIMethods.updatePetWithForm;
  const __uriData = buildUpdatePetWithFormURI({
    petId,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Updates a pet in the store with form data
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
* @param {integer} parameters.petId
 * ID of pet that needs to be updated
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function updatePetWithForm<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
    petId,
  } : APITypes.UpdatePetWithForm.Input,
  options: O,
) : Promise<Writeable<APITypes.UpdatePetWithForm.Output>> {
  const httpRequest = buildUpdatePetWithFormInput({
    body,
    petId,
  });

  return (await executeRequest(
    httpRequest,
    "updatePetWithForm",
    options,
  )) as APITypes.UpdatePetWithForm.Output;
}


/**
 * Build the "deletePet" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * Pet id to delete
 */
function buildDeletePetURI(
  {
    petId,
  } : Pick<APITypes.DeletePet.Input,
    'petId'
      >,
) : URIData {
  if(petId == null) {
    throw new Error('Missing required parameter: petId. Value : ' +  petId);
  }

  const __pathParts = [
    'pet',
    petId,
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "deletePet" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} [parameters.apiKey],
* @param {integer} parameters.petId
 * Pet id to delete
 */
function buildDeletePetInput(
  {
    apiKey,
    petId,
  } : APITypes.DeletePet.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.deletePet;
  const __uriData = buildDeletePetURI({
    petId,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
      'api_key': apiKey,
    }),
    body: undefined,
  };
}

/**
 * Deletes a pet
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} [parameters.apiKey],
* @param {integer} parameters.petId
 * Pet id to delete
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function deletePet<O>(
  executeRequest: RequestExecutor<O>,
  {
    apiKey,
    petId,
  } : APITypes.DeletePet.Input,
  options: O,
) : Promise<Writeable<APITypes.DeletePet.Output>> {
  const httpRequest = buildDeletePetInput({
    apiKey,
    petId,
  });

  return (await executeRequest(
    httpRequest,
    "deletePet",
    options,
  )) as APITypes.DeletePet.Output;
}


/**
 * Build the "uploadFile" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * ID of pet to update
 */
function buildUploadFileURI(
  {
    petId,
  } : Pick<APITypes.UploadFile.Input,
    'petId'
      >,
) : URIData {
  if(petId == null) {
    throw new Error('Missing required parameter: petId. Value : ' +  petId);
  }

  const __pathParts = [
    'pet',
    petId,
    'uploadImage',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "uploadFile" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet to update
 */
function buildUploadFileInput(
  {
    body,
    petId,
  } : APITypes.UploadFile.Input,
) : HTTPRequest<APITypes.UploadFile.Input['body']> {



  const __method = APIMethods.uploadFile;
  const __uriData = buildUploadFileURI({
    petId,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * uploads an image
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
* @param {integer} parameters.petId
 * ID of pet to update
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function uploadFile<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
    petId,
  } : APITypes.UploadFile.Input,
  options: O,
) : Promise<Writeable<APITypes.UploadFile.Output>> {
  const httpRequest = buildUploadFileInput({
    body,
    petId,
  });

  return (await executeRequest(
    httpRequest,
    "uploadFile",
    options,
  )) as APITypes.UploadFile.Output;
}


/**
 * Build the "getInventory" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetInventoryURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'store',
    'inventory',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getInventory" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildGetInventoryInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getInventory;
  const __uriData = buildGetInventoryURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Returns pet inventories by status
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getInventory<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<APITypes.GetInventory.Output>> {
  const httpRequest = buildGetInventoryInput({
  });

  return (await executeRequest(
    httpRequest,
    "getInventory",
    options,
  )) as APITypes.GetInventory.Output;
}


/**
 * Build the "placeOrder" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildPlaceOrderURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'store',
    'order',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "placeOrder" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildPlaceOrderInput(
  {
    body,
  } : APITypes.PlaceOrder.Input,
) : HTTPRequest<APITypes.PlaceOrder.Input['body']> {



  const __method = APIMethods.placeOrder;
  const __uriData = buildPlaceOrderURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Place an order for a pet
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function placeOrder<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  } : APITypes.PlaceOrder.Input,
  options: O,
) : Promise<Writeable<APITypes.PlaceOrder.Output>> {
  const httpRequest = buildPlaceOrderInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "placeOrder",
    options,
  )) as APITypes.PlaceOrder.Output;
}


/**
 * Build the "getOrderById" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 */
function buildGetOrderByIdURI(
  {
    orderId,
  } : Pick<APITypes.GetOrderById.Input,
    'orderId'
      >,
) : URIData {
  if(orderId == null) {
    throw new Error('Missing required parameter: orderId. Value : ' +  orderId);
  }

  const __pathParts = [
    'store',
    'order',
    orderId,
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getOrderById" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 */
function buildGetOrderByIdInput(
  {
    orderId,
  } : APITypes.GetOrderById.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getOrderById;
  const __uriData = buildGetOrderByIdURI({
    orderId,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Find purchase order by ID
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getOrderById<O>(
  executeRequest: RequestExecutor<O>,
  {
    orderId,
  } : APITypes.GetOrderById.Input,
  options: O,
) : Promise<Writeable<APITypes.GetOrderById.Output>> {
  const httpRequest = buildGetOrderByIdInput({
    orderId,
  });

  return (await executeRequest(
    httpRequest,
    "getOrderById",
    options,
  )) as APITypes.GetOrderById.Output;
}


/**
 * Build the "deleteOrder" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 */
function buildDeleteOrderURI(
  {
    orderId,
  } : Pick<APITypes.DeleteOrder.Input,
    'orderId'
      >,
) : URIData {
  if(orderId == null) {
    throw new Error('Missing required parameter: orderId. Value : ' +  orderId);
  }

  const __pathParts = [
    'store',
    'order',
    orderId,
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "deleteOrder" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 */
function buildDeleteOrderInput(
  {
    orderId,
  } : APITypes.DeleteOrder.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.deleteOrder;
  const __uriData = buildDeleteOrderURI({
    orderId,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Delete purchase order by ID
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function deleteOrder<O>(
  executeRequest: RequestExecutor<O>,
  {
    orderId,
  } : APITypes.DeleteOrder.Input,
  options: O,
) : Promise<Writeable<APITypes.DeleteOrder.Output>> {
  const httpRequest = buildDeleteOrderInput({
    orderId,
  });

  return (await executeRequest(
    httpRequest,
    "deleteOrder",
    options,
  )) as APITypes.DeleteOrder.Output;
}


/**
 * Build the "createUser" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildCreateUserURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'user',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "createUser" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildCreateUserInput(
  {
    body,
  } : APITypes.CreateUser.Input,
) : HTTPRequest<APITypes.CreateUser.Input['body']> {



  const __method = APIMethods.createUser;
  const __uriData = buildCreateUserURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Create user
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function createUser<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  } : APITypes.CreateUser.Input,
  options: O,
) : Promise<Writeable<APITypes.CreateUser.Output>> {
  const httpRequest = buildCreateUserInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "createUser",
    options,
  )) as APITypes.CreateUser.Output;
}


/**
 * Build the "createUsersWithArrayInput" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildCreateUsersWithArrayInputURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'user',
    'createWithArray',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "createUsersWithArrayInput" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildCreateUsersWithArrayInputInput(
  {
    body,
  } : APITypes.CreateUsersWithArrayInput.Input,
) : HTTPRequest<APITypes.CreateUsersWithArrayInput.Input['body']> {



  const __method = APIMethods.createUsersWithArrayInput;
  const __uriData = buildCreateUsersWithArrayInputURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Creates list of users with given input array
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function createUsersWithArrayInput<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  } : APITypes.CreateUsersWithArrayInput.Input,
  options: O,
) : Promise<Writeable<APITypes.CreateUsersWithArrayInput.Output>> {
  const httpRequest = buildCreateUsersWithArrayInputInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "createUsersWithArrayInput",
    options,
  )) as APITypes.CreateUsersWithArrayInput.Output;
}


/**
 * Build the "createUsersWithListInput" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildCreateUsersWithListInputURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'user',
    'createWithList',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "createUsersWithListInput" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildCreateUsersWithListInputInput(
  {
    body,
  } : APITypes.CreateUsersWithListInput.Input,
) : HTTPRequest<APITypes.CreateUsersWithListInput.Input['body']> {



  const __method = APIMethods.createUsersWithListInput;
  const __uriData = buildCreateUsersWithListInputURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Creates list of users with given input array
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function createUsersWithListInput<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  } : APITypes.CreateUsersWithListInput.Input,
  options: O,
) : Promise<Writeable<APITypes.CreateUsersWithListInput.Output>> {
  const httpRequest = buildCreateUsersWithListInputInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "createUsersWithListInput",
    options,
  )) as APITypes.CreateUsersWithListInput.Output;
}


/**
 * Build the "loginUser" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * The user name for login,
* @param {string} parameters.password
 * The password for login in clear text
 */
function buildLoginUserURI(
  {
    username,
    password,
  } : Pick<APITypes.LoginUser.Input,
    'username'|
    'password'
      >,
) : URIData {
  if(username == null) {
    throw new Error('Missing required parameter: username. Value : ' +  username);
  }
  if(password == null) {
    throw new Error('Missing required parameter: password. Value : ' +  password);
  }

  const __pathParts = [
    'user',
    'login',
  ];
  const __qs = cleanQuery({
    username: username,
    password: password,
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "loginUser" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The user name for login,
* @param {string} parameters.password
 * The password for login in clear text
 */
function buildLoginUserInput(
  {
    username,
    password,
  } : APITypes.LoginUser.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.loginUser;
  const __uriData = buildLoginUserURI({
    username,
    password,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Logs user into the system
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The user name for login,
* @param {string} parameters.password
 * The password for login in clear text
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function loginUser<O>(
  executeRequest: RequestExecutor<O>,
  {
    username,
    password,
  } : APITypes.LoginUser.Input,
  options: O,
) : Promise<Writeable<APITypes.LoginUser.Output>> {
  const httpRequest = buildLoginUserInput({
    username,
    password,
  });

  return (await executeRequest(
    httpRequest,
    "loginUser",
    options,
  )) as APITypes.LoginUser.Output;
}


/**
 * Build the "logoutUser" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildLogoutUserURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'user',
    'logout',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "logoutUser" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildLogoutUserInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.logoutUser;
  const __uriData = buildLogoutUserURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Logs out current logged in user session
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function logoutUser<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<APITypes.LogoutUser.Output>> {
  const httpRequest = buildLogoutUserInput({
  });

  return (await executeRequest(
    httpRequest,
    "logoutUser",
    options,
  )) as APITypes.LogoutUser.Output;
}


/**
 * Build the "getUserByName" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 */
function buildGetUserByNameURI(
  {
    username,
  } : Pick<APITypes.GetUserByName.Input,
    'username'
      >,
) : URIData {
  if(username == null) {
    throw new Error('Missing required parameter: username. Value : ' +  username);
  }

  const __pathParts = [
    'user',
    username,
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getUserByName" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 */
function buildGetUserByNameInput(
  {
    username,
  } : APITypes.GetUserByName.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getUserByName;
  const __uriData = buildGetUserByNameURI({
    username,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Get user by user name
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getUserByName<O>(
  executeRequest: RequestExecutor<O>,
  {
    username,
  } : APITypes.GetUserByName.Input,
  options: O,
) : Promise<Writeable<APITypes.GetUserByName.Output>> {
  const httpRequest = buildGetUserByNameInput({
    username,
  });

  return (await executeRequest(
    httpRequest,
    "getUserByName",
    options,
  )) as APITypes.GetUserByName.Output;
}


/**
 * Build the "updateUser" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * name that need to be deleted
 */
function buildUpdateUserURI(
  {
    username,
  } : Pick<APITypes.UpdateUser.Input,
    'username'
      >,
) : URIData {
  if(username == null) {
    throw new Error('Missing required parameter: username. Value : ' +  username);
  }

  const __pathParts = [
    'user',
    username,
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "updateUser" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * name that need to be deleted
 */
function buildUpdateUserInput(
  {
    body,
    username,
  } : APITypes.UpdateUser.Input,
) : HTTPRequest<APITypes.UpdateUser.Input['body']> {



  const __method = APIMethods.updateUser;
  const __uriData = buildUpdateUserURI({
    username,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Updated user
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
* @param {string} parameters.username
 * name that need to be deleted
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function updateUser<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
    username,
  } : APITypes.UpdateUser.Input,
  options: O,
) : Promise<Writeable<APITypes.UpdateUser.Output>> {
  const httpRequest = buildUpdateUserInput({
    body,
    username,
  });

  return (await executeRequest(
    httpRequest,
    "updateUser",
    options,
  )) as APITypes.UpdateUser.Output;
}


/**
 * Build the "deleteUser" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * The name that needs to be deleted
 */
function buildDeleteUserURI(
  {
    username,
  } : Pick<APITypes.DeleteUser.Input,
    'username'
      >,
) : URIData {
  if(username == null) {
    throw new Error('Missing required parameter: username. Value : ' +  username);
  }

  const __pathParts = [
    'user',
    username,
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "deleteUser" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be deleted
 */
function buildDeleteUserInput(
  {
    username,
  } : APITypes.DeleteUser.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.deleteUser;
  const __uriData = buildDeleteUserURI({
    username,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Delete user
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be deleted
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function deleteUser<O>(
  executeRequest: RequestExecutor<O>,
  {
    username,
  } : APITypes.DeleteUser.Input,
  options: O,
) : Promise<Writeable<APITypes.DeleteUser.Output>> {
  const httpRequest = buildDeleteUserInput({
    username,
  });

  return (await executeRequest(
    httpRequest,
    "deleteUser",
    options,
  )) as APITypes.DeleteUser.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with filterStatuses 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;

export namespace APITypes {
    export namespace GetPing {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getPingResponse200<200>;
        }
    }
}
export namespace Components {
    export namespace Responses {
        export type getPingResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetPingResponse200Body0;
        };
    }
    export namespace Schemas {
        export type ResponsesgetPingResponse200Body0 = {
            pong?: "pong";
        };
    }
}

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getPing,
};

export const APIURIBuilders = {
  getPing: buildGetPingURI,
};

export const APIMethods = {
  getPing: 'get',
} as const;

export const APIStatuses = {
  getPing: [200, 400],
} as const;

export const APIInputBuilders = {
  getPing: buildGetPingInput,
};


/**
 * Build the "getPing" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetPingURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'ping',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getPing" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildGetPingInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getPing;
  const __uriData = buildGetPingURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Checks API's availability.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getPing<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<APITypes.GetPing.Output>> {
  const httpRequest = buildGetPingInput({
  });

  return (await executeRequest(
    httpRequest,
    "getPing",
    options,
  )) as APITypes.GetPing.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with refs 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;

export namespace APITypes {
    export namespace PutEcho {
        export type Body = Components.RequestBodies.PutEchoRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.putEchoResponse200<200>;
        }
    }
}
export namespace Components {
    export namespace RequestBodies {
        export type PutEchoRequestBody = Components.Schemas.Echo;
    }
    export namespace Responses {
        export type putEchoResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesputEchoResponse200Body0;
        };
    }
    export namespace Schemas {
        export type Echo = {
            echo: string;
        };
        export type ResponsesputEchoResponse200Body0 = {
            echo: string;
        };
    }
}

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  putEcho,
};

export const APIURIBuilders = {
  putEcho: buildPutEchoURI,
};

export const APIMethods = {
  putEcho: 'put',
} as const;

export const APIStatuses = {
  putEcho: [200],
} as const;

export const APIInputBuilders = {
  putEcho: buildPutEchoInput,
};


/**
 * Build the "putEcho" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildPutEchoURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'echo',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "putEcho" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildPutEchoInput(
  {
    body,
  } : APITypes.PutEcho.Input,
) : HTTPRequest<APITypes.PutEcho.Input['body']> {



  const __method = APIMethods.putEcho;
  const __uriData = buildPutEchoURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Echoes what it takes.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function putEcho<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  } : APITypes.PutEcho.Input,
  options: O,
) : Promise<Writeable<APITypes.PutEcho.Output>> {
  const httpRequest = buildPutEchoInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "putEcho",
    options,
  )) as APITypes.PutEcho.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with sdkName 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;

export namespace FooAPITypes {
    export namespace GetOpenAPI {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getOpenAPIResponse200<200>;
        }
    }
    export namespace GetPing {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getPingResponse200<200>;
        }
    }
    export namespace GetDelay {
        export type Output = Responses.$204;
        export type Input = {
            readonly duration: Parameters.Duration;
            readonly cookie?: Parameters.Cookie;
            readonly xApplicationVersion?: Parameters.XApplicationVersion;
        };
        export namespace Responses {
            export type $204 = Components.Responses.getDelayResponse204<204>;
        }
        export namespace Parameters {
            export type Duration = Components.Parameters.GetDelay0;
            export type Cookie = Components.Parameters.GetDelay1;
            export type XApplicationVersion = Components.Parameters.GetDelay2;
        }
    }
    export namespace GetDiagnostic {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getDiagnosticResponse200<200>;
        }
    }
    export namespace GetTime {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getTimeResponse200<200>;
        }
    }
    export namespace PutEcho {
        export type Body = Components.RequestBodies.PutEchoRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.putEchoResponse200<200>;
        }
    }
}
export namespace Components {
    export namespace RequestBodies {
        export type PutEchoRequestBody = Components.Schemas.RequestBodiesputEchoRequestBodyBody0;
    }
    export namespace Parameters {
        export type GetDelay0 = number;
        export type GetDelay1 = string;
        export type GetDelay2 = string;
    }
    export namespace Responses {
        export type getDelayResponse204<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: unknown;
        };
        export type getOpenAPIResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetOpenAPIResponse200Body0;
        };
        export type getPingResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetPingResponse200Body0;
        };
        export type getDiagnosticResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetDiagnosticResponse200Body0;
        };
        export type getTimeResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetTimeResponse200Body0;
        };
        export type putEchoResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesputEchoResponse200Body0;
        };
    }
    export namespace Schemas {
        export type RequestBodiesputEchoRequestBodyBody0 = {
            echo: string;
        };
        export type ResponsesgetOpenAPIResponse200Body0 = {};
        export type ResponsesgetPingResponse200Body0 = {
            pong?: "pong";
        };
        export type ResponsesgetDiagnosticResponse200Body0 = {
            [pattern: string]: unknown;
        };
        export type ResponsesgetTimeResponse200Body0 = {
            currentDate?: string;
        };
        export type ResponsesputEchoResponse200Body0 = {
            echo: string;
        };
    }
}

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getOpenAPI,
  getPing,
  getDelay,
  getDiagnostic,
  getTime,
  putEcho,
};

export const APIURIBuilders = {
  getOpenAPI: buildGetOpenAPIURI,
  getPing: buildGetPingURI,
  getDelay: buildGetDelayURI,
  getDiagnostic: buildGetDiagnosticURI,
  getTime: buildGetTimeURI,
  putEcho: buildPutEchoURI,
};

export const APIMethods = {
  getOpenAPI: 'get',
  getPing: 'get',
  getDelay: 'get',
  getDiagnostic: 'get',
  getTime: 'get',
  putEcho: 'put',
} as const;

export const APIStatuses = {
  getOpenAPI: [200],
  getPing: [200],
  getDelay: [204],
  getDiagnostic: [200],
  getTime: [200],
  putEcho: [200],
} as const;

export const APIInputBuilders = {
  getOpenAPI: buildGetOpenAPIInput,
  getPing: buildGetPingInput,
  getDelay: buildGetDelayInput,
  getDiagnostic: buildGetDiagnosticInput,
  getTime: buildGetTimeInput,
  putEcho: buildPutEchoInput,
};


/**
 * Build the "getOpenAPI" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetOpenAPIURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'openAPI',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getOpenAPI" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildGetOpenAPIInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getOpenAPI;
  const __uriData = buildGetOpenAPIURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Get API documentation.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getOpenAPI<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<FooAPITypes.GetOpenAPI.Output>> {
  const httpRequest = buildGetOpenAPIInput({
  });

  return (await executeRequest(
    httpRequest,
    "getOpenAPI",
    options,
  )) as FooAPITypes.GetOpenAPI.Output;
}


/**
 * Build the "getPing" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetPingURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'ping',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getPing" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildGetPingInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getPing;
  const __uriData = buildGetPingURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Checks API's availability.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getPing<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<FooAPITypes.GetPing.Output>> {
  const httpRequest = buildGetPingInput({
  });

  return (await executeRequest(
    httpRequest,
    "getPing",
    options,
  )) as FooAPITypes.GetPing.Output;
}


/**
 * Build the "getDelay" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 */
function buildGetDelayURI(
  {
    duration,
  } : Pick<FooAPITypes.GetDelay.Input,
    'duration'
      >,
) : URIData {
  if(duration == null) {
    throw new Error('Missing required parameter: duration. Value : ' +  duration);
  }

  const __pathParts = [
    'delay',
  ];
  const __qs = cleanQuery({
    duration: duration,
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getDelay" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 */
function buildGetDelayInput(
  {
    duration,
    xApplicationVersion,
  } : FooAPITypes.GetDelay.Input,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getDelay;
  const __uriData = buildGetDelayURI({
    duration,
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
      'X-Application-Version': xApplicationVersion,
    }),
    body: undefined,
  };
}

/**
 * Answer after a given delay.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getDelay<O>(
  executeRequest: RequestExecutor<O>,
  {
    duration,
    xApplicationVersion,
  } : FooAPITypes.GetDelay.Input,
  options: O,
) : Promise<Writeable<FooAPITypes.GetDelay.Output>> {
  const httpRequest = buildGetDelayInput({
    duration,
    xApplicationVersion,
  });

  return (await executeRequest(
    httpRequest,
    "getDelay",
    options,
  )) as FooAPITypes.GetDelay.Output;
}


/**
 * Build the "getDiagnostic" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetDiagnosticURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'diag',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getDiagnostic" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildGetDiagnosticInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getDiagnostic;
  const __uriData = buildGetDiagnosticURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Returns current API's transactions.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getDiagnostic<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<FooAPITypes.GetDiagnostic.Output>> {
  const httpRequest = buildGetDiagnosticInput({
  });

  return (await executeRequest(
    httpRequest,
    "getDiagnostic",
    options,
  )) as FooAPITypes.GetDiagnostic.Output;
}


/**
 * Build the "getTime" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetTimeURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'time',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getTime" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildGetTimeInput(
  _: unknown,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getTime;
  const __uriData = buildGetTimeURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  };
}

/**
 * Get API internal clock date.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getTime<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
) : Promise<Writeable<FooAPITypes.GetTime.Output>> {
  const httpRequest = buildGetTimeInput({
  });

  return (await executeRequest(
    httpRequest,
    "getTime",
    options,
  )) as FooAPITypes.GetTime.Output;
}


/**
 * Build the "putEcho" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildPutEchoURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'echo',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "putEcho" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */
function buildPutEchoInput(
  {
    body,
  } : FooAPITypes.PutEcho.Input,
) : HTTPRequest<FooAPITypes.PutEcho.Input['body']> {



  const __method = APIMethods.putEcho;
  const __uriData = buildPutEchoURI({
  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  };
}

/**
 * Echoes what it takes.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function putEcho<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  } : FooAPITypes.PutEcho.Input,
  options: O,
) : Promise<Writeable<FooAPITypes.PutEcho.Output>> {
  const httpRequest = buildPutEchoInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "putEcho",
    options,
  )) as FooAPITypes.PutEcho.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

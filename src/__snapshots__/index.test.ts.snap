// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateSDKFromOpenAPI should work 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

import querystring from 'querystring';
import axios from 'axios';
import type { AxiosRequestConfig } from 'axios';

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIBuilderOptions = {
  baseURL?: string;
};
export type InputBuilderOptions = URIBuilderOptions & {
    headers?: Headers;
};
export type URIData = {
  baseURL: string;
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type { APITypes, Components };

declare namespace APITypes {
    export namespace GetOpenAPI {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getOpenAPIResponse200<200>;
        }
    }
    export namespace GetPing {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getPingResponse200<200>;
        }
    }
    export namespace GetDelay {
        export type Output = Responses.$204;
        export type Input = {
            readonly duration: Parameters.Duration;
            readonly cookie?: Parameters.Cookie;
            readonly xApplicationVersion?: Parameters.XApplicationVersion;
        };
        export namespace Responses {
            export type $204 = Components.Responses.getDelayResponse204<204>;
        }
        export namespace Parameters {
            export type Duration = Components.Parameters.GetDelay0;
            export type Cookie = Components.Parameters.GetDelay1;
            export type XApplicationVersion = Components.Parameters.GetDelay2;
        }
    }
    export namespace GetDiagnostic {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getDiagnosticResponse200<200>;
        }
    }
    export namespace GetTime {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getTimeResponse200<200>;
        }
    }
    export namespace PutEcho {
        export type Body = Components.RequestBodies.PutEchoRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.putEchoResponse200<200>;
        }
    }
}
declare namespace Components {
    export namespace RequestBodies {
        export type PutEchoRequestBody = Components.Schemas.RequestBodiesputEchoRequestBodyBody0;
    }
    export namespace Parameters {
        export type GetDelay0 = NonNullable<number>;
        export type GetDelay1 = NonNullable<string>;
        export type GetDelay2 = NonNullable<string>;
    }
    export namespace Responses {
        type getDelayResponse204<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getOpenAPIResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetOpenAPIResponse200Body0;
        };
        type getPingResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetPingResponse200Body0;
        };
        type getDiagnosticResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetDiagnosticResponse200Body0;
        };
        type getTimeResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetTimeResponse200Body0;
        };
        type putEchoResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesputEchoResponse200Body0;
        };
    }
    export namespace Schemas {
        export type RequestBodiesputEchoRequestBodyBody0 = NonNullable<{
            echo: NonNullable<string>;
        }>;
        export type ResponsesgetOpenAPIResponse200Body0 = NonNullable<{}>;
        export type ResponsesgetPingResponse200Body0 = NonNullable<{
            pong?: \\"pong\\";
        }>;
        export type ResponsesgetDiagnosticResponse200Body0 = NonNullable<{
            [pattern: string]: unknown;
        }>;
        export type ResponsesgetTimeResponse200Body0 = NonNullable<{
            currentDate?: NonNullable<string>;
        }>;
        export type ResponsesputEchoResponse200Body0 = NonNullable<{
            echo: NonNullable<string>;
        }>;
    }
}

const DEFAULT_BASE_URL = 'http://192.168.10.149:8000/v3';
const URI_BUILDER_DEFAULTS = {
  baseURL: DEFAULT_BASE_URL,
};
const INPUT_BUILDER_DEFAULTS = {
  baseURL: DEFAULT_BASE_URL,
  headers: {},
};

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getOpenAPI,
  getPing,
  getDelay,
  getDiagnostic,
  getTime,
  putEcho,
};

export const APIURIBuilders = {
  getOpenAPI: buildGetOpenAPIURI,
  getPing: buildGetPingURI,
  getDelay: buildGetDelayURI,
  getDiagnostic: buildGetDiagnosticURI,
  getTime: buildGetTimeURI,
  putEcho: buildPutEchoURI,
};

export const APIMethods = {
  getOpenAPI: 'get',
  getPing: 'get',
  getDelay: 'get',
  getDiagnostic: 'get',
  getTime: 'get',
  putEcho: 'put',
} as const;

export const APIInputBuilders = {
  getOpenAPI: buildGetOpenAPIInput,
  getPing: buildGetPingInput,
  getDelay: buildGetDelayInput,
  getDiagnostic: buildGetDiagnosticInput,
  getTime: buildGetTimeInput,
  putEcho: buildPutEchoInput,
};


/**
 * Build the \\"getOpenAPI\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetOpenAPIURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'openAPI',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getOpenAPI\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetOpenAPIInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getOpenAPI;
  const __uriData = buildGetOpenAPIURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Get API documentation.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getOpenAPI(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.GetOpenAPI.Output>> {
  const httpRequest = buildGetOpenAPIInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetOpenAPI.Output;
}


/**
 * Build the \\"getPing\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetPingURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'ping',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getPing\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetPingInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getPing;
  const __uriData = buildGetPingURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Checks API's availability.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getPing(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.GetPing.Output>> {
  const httpRequest = buildGetPingInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetPing.Output;
}


/**
 * Build the \\"getDelay\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetDelayURI(
  {
    duration,
  } : Pick<APITypes.GetDelay.Input,
    'duration'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(duration == null) {
    throw new Error('Missing required parameter : duration. Value : ' +  duration);
  }

  const __pathParts = [
    'delay',
  ];
  const __qs = cleanQuery({
    duration: duration,
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getDelay\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetDelayInput(
  {
    duration,
    xApplicationVersion,
  } : APITypes.GetDelay.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getDelay;
  const __uriData = buildGetDelayURI({
    duration,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
      'X-Application-Version': xApplicationVersion,
    })),
    body: undefined,
  };
}

/**
 * Answer after a given delay.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getDelay(
  {
    duration,
    xApplicationVersion,
  } : APITypes.GetDelay.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.GetDelay.Output>> {
  const httpRequest = buildGetDelayInput({
    duration,
    xApplicationVersion,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetDelay.Output;
}


/**
 * Build the \\"getDiagnostic\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetDiagnosticURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'diag',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getDiagnostic\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetDiagnosticInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getDiagnostic;
  const __uriData = buildGetDiagnosticURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Returns current API's transactions.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getDiagnostic(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.GetDiagnostic.Output>> {
  const httpRequest = buildGetDiagnosticInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetDiagnostic.Output;
}


/**
 * Build the \\"getTime\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetTimeURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'time',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getTime\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetTimeInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getTime;
  const __uriData = buildGetTimeURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Get API internal clock date.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getTime(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.GetTime.Output>> {
  const httpRequest = buildGetTimeInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetTime.Output;
}


/**
 * Build the \\"putEcho\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildPutEchoURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'echo',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"putEcho\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildPutEchoInput(
  {
    body,
  } : APITypes.PutEcho.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.PutEcho.Input['body']> {



  const __method = APIMethods.putEcho;
  const __uriData = buildPutEchoURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Echoes what it takes.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function putEcho(
  {
    body,
  } : APITypes.PutEcho.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.PutEcho.Output>> {
  const httpRequest = buildPutEchoInput({
    body,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.PutEcho.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with Pet Store 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

import querystring from 'querystring';
import axios from 'axios';
import type { AxiosRequestConfig } from 'axios';

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIBuilderOptions = {
  baseURL?: string;
};
export type InputBuilderOptions = URIBuilderOptions & {
    headers?: Headers;
};
export type URIData = {
  baseURL: string;
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type { APITypes, Components };

declare namespace APITypes {
    export namespace UpdatePet {
        export type Body = Components.RequestBodies.Pet;
        export type Output = Responses.$400 | Responses.$404 | Responses.$405;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $400 = Components.Responses.updatePetResponse400<400>;
            export type $404 = Components.Responses.updatePetResponse404<404>;
            export type $405 = Components.Responses.updatePetResponse405<405>;
        }
    }
    export namespace AddPet {
        export type Body = Components.RequestBodies.Pet;
        export type Output = Responses.$405;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $405 = Components.Responses.addPetResponse405<405>;
        }
    }
    export namespace FindPetsByStatus {
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly status: Parameters.Status;
        };
        export namespace Responses {
            export type $200 = Components.Responses.findPetsByStatusResponse200<200>;
            export type $400 = Components.Responses.findPetsByStatusResponse400<400>;
        }
        export namespace Parameters {
            export type Status = Components.Parameters.FindPetsByStatus0;
        }
    }
    export namespace FindPetsByTags {
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly tags: Parameters.Tags;
        };
        export namespace Responses {
            export type $200 = Components.Responses.findPetsByTagsResponse200<200>;
            export type $400 = Components.Responses.findPetsByTagsResponse400<400>;
        }
        export namespace Parameters {
            export type Tags = Components.Parameters.FindPetsByTags0;
        }
    }
    export namespace GetPetById {
        export type Output = Responses.$200 | Responses.$400 | Responses.$404;
        export type Input = {
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $200 = Components.Responses.getPetByIdResponse200<200>;
            export type $400 = Components.Responses.getPetByIdResponse400<400>;
            export type $404 = Components.Responses.getPetByIdResponse404<404>;
        }
        export namespace Parameters {
            export type PetId = Components.Parameters.GetPetById0;
        }
    }
    export namespace UpdatePetWithForm {
        export type Body = Components.RequestBodies.UpdatePetWithFormRequestBody;
        export type Output = Responses.$405;
        export type Input = {
            readonly body?: Body;
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $405 = Components.Responses.updatePetWithFormResponse405<405>;
        }
        export namespace Parameters {
            export type PetId = Components.Parameters.UpdatePetWithForm0;
        }
    }
    export namespace DeletePet {
        export type Output = Responses.$400;
        export type Input = {
            readonly apiKey?: Parameters.ApiKey;
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $400 = Components.Responses.deletePetResponse400<400>;
        }
        export namespace Parameters {
            export type ApiKey = Components.Parameters.DeletePet0;
            export type PetId = Components.Parameters.DeletePet1;
        }
    }
    export namespace UploadFile {
        export type Body = Components.RequestBodies.UploadFileRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $200 = Components.Responses.uploadFileResponse200<200>;
        }
        export namespace Parameters {
            export type PetId = Components.Parameters.UploadFile0;
        }
    }
    export namespace GetInventory {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getInventoryResponse200<200>;
        }
    }
    export namespace PlaceOrder {
        export type Body = Components.RequestBodies.PlaceOrderRequestBody;
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.placeOrderResponse200<200>;
            export type $400 = Components.Responses.placeOrderResponse400<400>;
        }
    }
    export namespace GetOrderById {
        export type Output = Responses.$200 | Responses.$400 | Responses.$404;
        export type Input = {
            readonly orderId: Parameters.OrderId;
        };
        export namespace Responses {
            export type $200 = Components.Responses.getOrderByIdResponse200<200>;
            export type $400 = Components.Responses.getOrderByIdResponse400<400>;
            export type $404 = Components.Responses.getOrderByIdResponse404<404>;
        }
        export namespace Parameters {
            export type OrderId = Components.Parameters.GetOrderById0;
        }
    }
    export namespace DeleteOrder {
        export type Output = Responses.$400 | Responses.$404;
        export type Input = {
            readonly orderId: Parameters.OrderId;
        };
        export namespace Responses {
            export type $400 = Components.Responses.deleteOrderResponse400<400>;
            export type $404 = Components.Responses.deleteOrderResponse404<404>;
        }
        export namespace Parameters {
            export type OrderId = Components.Parameters.DeleteOrder0;
        }
    }
    export namespace CreateUser {
        export type Body = Components.RequestBodies.CreateUserRequestBody;
        export type Output = Responses.$default;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $default = Components.Responses.createUserResponsedefault<number>;
        }
    }
    export namespace CreateUsersWithArrayInput {
        export type Body = Components.RequestBodies.UserArray;
        export type Output = Responses.$default;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $default = Components.Responses.createUsersWithArrayInputResponsedefault<number>;
        }
    }
    export namespace CreateUsersWithListInput {
        export type Body = Components.RequestBodies.UserArray;
        export type Output = Responses.$default;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $default = Components.Responses.createUsersWithListInputResponsedefault<number>;
        }
    }
    export namespace LoginUser {
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly username: Parameters.Username;
            readonly password: Parameters.Password;
        };
        export namespace Responses {
            export type $200 = Components.Responses.loginUserResponse200<200>;
            export type $400 = Components.Responses.loginUserResponse400<400>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.LoginUser0;
            export type Password = Components.Parameters.LoginUser1;
        }
    }
    export namespace LogoutUser {
        export type Output = Responses.$default;
        export type Input = {};
        export namespace Responses {
            export type $default = Components.Responses.logoutUserResponsedefault<number>;
        }
    }
    export namespace GetUserByName {
        export type Output = Responses.$200 | Responses.$400 | Responses.$404;
        export type Input = {
            readonly username: Parameters.Username;
        };
        export namespace Responses {
            export type $200 = Components.Responses.getUserByNameResponse200<200>;
            export type $400 = Components.Responses.getUserByNameResponse400<400>;
            export type $404 = Components.Responses.getUserByNameResponse404<404>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.GetUserByName0;
        }
    }
    export namespace UpdateUser {
        export type Body = Components.RequestBodies.UpdateUserRequestBody;
        export type Output = Responses.$400 | Responses.$404;
        export type Input = {
            readonly body: Body;
            readonly username: Parameters.Username;
        };
        export namespace Responses {
            export type $400 = Components.Responses.updateUserResponse400<400>;
            export type $404 = Components.Responses.updateUserResponse404<404>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.UpdateUser0;
        }
    }
    export namespace DeleteUser {
        export type Output = Responses.$400 | Responses.$404;
        export type Input = {
            readonly username: Parameters.Username;
        };
        export namespace Responses {
            export type $400 = Components.Responses.deleteUserResponse400<400>;
            export type $404 = Components.Responses.deleteUserResponse404<404>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.DeleteUser0;
        }
    }
}
declare namespace Components {
    export namespace RequestBodies {
        export type UserArray = Components.Schemas.RequestBodiesUserArrayBody0;
        export type Pet = Components.Schemas.Pet | Components.Schemas.Pet;
        export type UpdatePetWithFormRequestBody = Components.Schemas.Body;
        export type UploadFileRequestBody = Components.Schemas.Body_1;
        export type PlaceOrderRequestBody = Components.Schemas.Order;
        export type CreateUserRequestBody = Components.Schemas.User;
        export type UpdateUserRequestBody = Components.Schemas.User;
    }
    export namespace Parameters {
        export type GetPetById0 = NonNullable<number>;
        export type UpdatePetWithForm0 = NonNullable<number>;
        export type DeletePet0 = NonNullable<string>;
        export type DeletePet1 = NonNullable<number>;
        export type UploadFile0 = NonNullable<number>;
        export type GetOrderById0 = NonNullable<number>;
        export type DeleteOrder0 = NonNullable<string>;
        export type LoginUser0 = NonNullable<string>;
        export type LoginUser1 = NonNullable<string>;
        export type GetUserByName0 = NonNullable<string>;
        export type UpdateUser0 = NonNullable<string>;
        export type DeleteUser0 = NonNullable<string>;
        export type FindPetsByStatus0 = NonNullable<(\\"available\\" | \\"pending\\" | \\"sold\\")[]>;
        export type FindPetsByTags0 = NonNullable<NonNullable<string>[]>;
    }
    export namespace Responses {
        type updatePetResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type updatePetResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type updatePetResponse405<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type addPetResponse405<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type findPetsByStatusResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type findPetsByTagsResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getPetByIdResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getPetByIdResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type updatePetWithFormResponse405<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type deletePetResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type placeOrderResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getOrderByIdResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getOrderByIdResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type deleteOrderResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type deleteOrderResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type createUserResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type createUsersWithArrayInputResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type createUsersWithListInputResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type loginUserResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type logoutUserResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getUserByNameResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getUserByNameResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type updateUserResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type updateUserResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type deleteUserResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type deleteUserResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type findPetsByStatusResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesfindPetsByStatusResponse200Body0 | Components.Schemas.ResponsesfindPetsByStatusResponse200Body1;
        };
        type findPetsByTagsResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesfindPetsByTagsResponse200Body0 | Components.Schemas.ResponsesfindPetsByTagsResponse200Body1;
        };
        type getPetByIdResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.Pet | Components.Schemas.Pet;
        };
        type uploadFileResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ApiResponse;
        };
        type getInventoryResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetInventoryResponse200Body0;
        };
        type placeOrderResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.Order | Components.Schemas.Order;
        };
        type getOrderByIdResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.Order | Components.Schemas.Order;
        };
        type getUserByNameResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.User | Components.Schemas.User;
        };
        type loginUserResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly \\"x-rate-limit\\"?: Components.Headers.LoginUserResponse200HeadersXRateLimit;
                readonly \\"x-expires-after\\"?: Components.Headers.LoginUserResponse200HeadersXExpiresAfter;
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesloginUserResponse200Body0 | Components.Schemas.ResponsesloginUserResponse200Body1;
        };
    }
    export namespace Headers {
        export type LoginUserResponse200HeadersXRateLimit = NonNullable<number>;
        export type LoginUserResponse200HeadersXExpiresAfter = NonNullable<string>;
    }
    export namespace Schemas {
        export type RequestBodiesUserArrayBody0 = NonNullable<Components.Schemas.User[]>;
        export type Pet = NonNullable<{
            id?: NonNullable<number>;
            category?: Components.Schemas.Category;
            name: NonNullable<string>;
            photoUrls: NonNullable<NonNullable<string>[]>;
            tags?: NonNullable<Components.Schemas.Tag[]>;
            status?: \\"available\\" | \\"pending\\" | \\"sold\\";
        }>;
        export type Body = NonNullable<{
            name?: NonNullable<string>;
            status?: NonNullable<string>;
        }>;
        export type Body_1 = NonNullable<{
            additionalMetadata?: NonNullable<string>;
            file?: NonNullable<string>;
        }>;
        export type Order = NonNullable<{
            id?: NonNullable<number>;
            petId?: NonNullable<number>;
            quantity?: NonNullable<number>;
            shipDate?: NonNullable<string>;
            status?: \\"placed\\" | \\"approved\\" | \\"delivered\\";
            complete?: NonNullable<boolean>;
        }>;
        export type User = NonNullable<{
            id?: NonNullable<number>;
            username?: NonNullable<string>;
            firstName?: NonNullable<string>;
            lastName?: NonNullable<string>;
            email?: NonNullable<string>;
            password?: NonNullable<string>;
            phone?: NonNullable<string>;
            userStatus?: NonNullable<number>;
        }>;
        export type ResponsesfindPetsByStatusResponse200Body0 = NonNullable<Components.Schemas.Pet[]>;
        export type ResponsesfindPetsByStatusResponse200Body1 = NonNullable<Components.Schemas.Pet[]>;
        export type ResponsesfindPetsByTagsResponse200Body0 = NonNullable<Components.Schemas.Pet[]>;
        export type ResponsesfindPetsByTagsResponse200Body1 = NonNullable<Components.Schemas.Pet[]>;
        export type ApiResponse = NonNullable<{
            code?: NonNullable<number>;
            type?: NonNullable<string>;
            message?: NonNullable<string>;
        }>;
        export type ResponsesgetInventoryResponse200Body0 = NonNullable<{
            [pattern: string]: unknown;
        }>;
        export type ResponsesloginUserResponse200Body0 = NonNullable<string>;
        export type ResponsesloginUserResponse200Body1 = NonNullable<string>;
        export type Category = NonNullable<{
            id?: NonNullable<number>;
            name?: NonNullable<string>;
        }>;
        export type Tag = NonNullable<{
            id?: NonNullable<number>;
            name?: NonNullable<string>;
        }>;
    }
}

const DEFAULT_BASE_URL = 'http://192.168.10.149:8000/v3';
const URI_BUILDER_DEFAULTS = {
  baseURL: DEFAULT_BASE_URL,
};
const INPUT_BUILDER_DEFAULTS = {
  baseURL: DEFAULT_BASE_URL,
  headers: {},
};

/**
 * This is a sample server Petstore server. For this sample, you can use the api key \`special-key\` to test the authorization filters. For OAuth2 flow, you may use \`user\` as both username and password when asked to login.
 * @module API
 * @version 1.0.0
 */
const API = {
  updatePet,
  addPet,
  findPetsByStatus,
  findPetsByTags,
  getPetById,
  updatePetWithForm,
  deletePet,
  uploadFile,
  getInventory,
  placeOrder,
  getOrderById,
  deleteOrder,
  createUser,
  createUsersWithArrayInput,
  createUsersWithListInput,
  loginUser,
  logoutUser,
  getUserByName,
  updateUser,
  deleteUser,
};

export const APIURIBuilders = {
  updatePet: buildUpdatePetURI,
  addPet: buildAddPetURI,
  findPetsByStatus: buildFindPetsByStatusURI,
  findPetsByTags: buildFindPetsByTagsURI,
  getPetById: buildGetPetByIdURI,
  updatePetWithForm: buildUpdatePetWithFormURI,
  deletePet: buildDeletePetURI,
  uploadFile: buildUploadFileURI,
  getInventory: buildGetInventoryURI,
  placeOrder: buildPlaceOrderURI,
  getOrderById: buildGetOrderByIdURI,
  deleteOrder: buildDeleteOrderURI,
  createUser: buildCreateUserURI,
  createUsersWithArrayInput: buildCreateUsersWithArrayInputURI,
  createUsersWithListInput: buildCreateUsersWithListInputURI,
  loginUser: buildLoginUserURI,
  logoutUser: buildLogoutUserURI,
  getUserByName: buildGetUserByNameURI,
  updateUser: buildUpdateUserURI,
  deleteUser: buildDeleteUserURI,
};

export const APIMethods = {
  updatePet: 'put',
  addPet: 'post',
  findPetsByStatus: 'get',
  findPetsByTags: 'get',
  getPetById: 'get',
  updatePetWithForm: 'post',
  deletePet: 'delete',
  uploadFile: 'post',
  getInventory: 'get',
  placeOrder: 'post',
  getOrderById: 'get',
  deleteOrder: 'delete',
  createUser: 'post',
  createUsersWithArrayInput: 'post',
  createUsersWithListInput: 'post',
  loginUser: 'get',
  logoutUser: 'get',
  getUserByName: 'get',
  updateUser: 'put',
  deleteUser: 'delete',
} as const;

export const APIInputBuilders = {
  updatePet: buildUpdatePetInput,
  addPet: buildAddPetInput,
  findPetsByStatus: buildFindPetsByStatusInput,
  findPetsByTags: buildFindPetsByTagsInput,
  getPetById: buildGetPetByIdInput,
  updatePetWithForm: buildUpdatePetWithFormInput,
  deletePet: buildDeletePetInput,
  uploadFile: buildUploadFileInput,
  getInventory: buildGetInventoryInput,
  placeOrder: buildPlaceOrderInput,
  getOrderById: buildGetOrderByIdInput,
  deleteOrder: buildDeleteOrderInput,
  createUser: buildCreateUserInput,
  createUsersWithArrayInput: buildCreateUsersWithArrayInputInput,
  createUsersWithListInput: buildCreateUsersWithListInputInput,
  loginUser: buildLoginUserInput,
  logoutUser: buildLogoutUserInput,
  getUserByName: buildGetUserByNameInput,
  updateUser: buildUpdateUserInput,
  deleteUser: buildDeleteUserInput,
};


/**
 * Build the \\"updatePet\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildUpdatePetURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'pet',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"updatePet\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildUpdatePetInput(
  {
    body,
  } : APITypes.UpdatePet.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.UpdatePet.Input['body']> {



  const __method = APIMethods.updatePet;
  const __uriData = buildUpdatePetURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Update an existing pet
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function updatePet(
  {
    body,
  } : APITypes.UpdatePet.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.UpdatePet.Output>> {
  const httpRequest = buildUpdatePetInput({
    body,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UpdatePet.Output;
}


/**
 * Build the \\"addPet\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildAddPetURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'pet',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"addPet\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildAddPetInput(
  {
    body,
  } : APITypes.AddPet.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.AddPet.Input['body']> {



  const __method = APIMethods.addPet;
  const __uriData = buildAddPetURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Add a new pet to the store
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function addPet(
  {
    body,
  } : APITypes.AddPet.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.AddPet.Output>> {
  const httpRequest = buildAddPetInput({
    body,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.AddPet.Output;
}


/**
 * Build the \\"findPetsByStatus\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {array} parameters.status
 * Status values that need to be considered for filter
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildFindPetsByStatusURI(
  {
    status,
  } : Pick<APITypes.FindPetsByStatus.Input,
    'status'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(status == null) {
    throw new Error('Missing required parameter : status. Value : ' +  status);
  }

  const __pathParts = [
    'pet',
    'findByStatus',
  ];
  const __qs = cleanQuery({
    status: status,
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"findPetsByStatus\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.status
 * Status values that need to be considered for filter
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildFindPetsByStatusInput(
  {
    status,
  } : APITypes.FindPetsByStatus.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.findPetsByStatus;
  const __uriData = buildFindPetsByStatusURI({
    status,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Finds Pets by status
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.status
 * Status values that need to be considered for filter
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function findPetsByStatus(
  {
    status,
  } : APITypes.FindPetsByStatus.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.FindPetsByStatus.Output>> {
  const httpRequest = buildFindPetsByStatusInput({
    status,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.FindPetsByStatus.Output;
}


/**
 * Build the \\"findPetsByTags\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {array} parameters.tags
 * Tags to filter by
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildFindPetsByTagsURI(
  {
    tags,
  } : Pick<APITypes.FindPetsByTags.Input,
    'tags'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(tags == null) {
    throw new Error('Missing required parameter : tags. Value : ' +  tags);
  }

  const __pathParts = [
    'pet',
    'findByTags',
  ];
  const __qs = cleanQuery({
    tags: tags,
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"findPetsByTags\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.tags
 * Tags to filter by
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildFindPetsByTagsInput(
  {
    tags,
  } : APITypes.FindPetsByTags.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.findPetsByTags;
  const __uriData = buildFindPetsByTagsURI({
    tags,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Finds Pets by tags
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.tags
 * Tags to filter by
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function findPetsByTags(
  {
    tags,
  } : APITypes.FindPetsByTags.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.FindPetsByTags.Output>> {
  const httpRequest = buildFindPetsByTagsInput({
    tags,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.FindPetsByTags.Output;
}


/**
 * Build the \\"getPetById\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * ID of pet to return
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetPetByIdURI(
  {
    petId,
  } : Pick<APITypes.GetPetById.Input,
    'petId'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }

  const __pathParts = [
    'pet',
    petId,
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getPetById\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet to return
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetPetByIdInput(
  {
    petId,
  } : APITypes.GetPetById.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getPetById;
  const __uriData = buildGetPetByIdURI({
    petId,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Find pet by ID
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet to return
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getPetById(
  {
    petId,
  } : APITypes.GetPetById.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.GetPetById.Output>> {
  const httpRequest = buildGetPetByIdInput({
    petId,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetPetById.Output;
}


/**
 * Build the \\"updatePetWithForm\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * ID of pet that needs to be updated
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildUpdatePetWithFormURI(
  {
    petId,
  } : Pick<APITypes.UpdatePetWithForm.Input,
    'petId'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }

  const __pathParts = [
    'pet',
    petId,
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"updatePetWithForm\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet that needs to be updated
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildUpdatePetWithFormInput(
  {
    body,
    petId,
  } : APITypes.UpdatePetWithForm.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.UpdatePetWithForm.Input['body']> {



  const __method = APIMethods.updatePetWithForm;
  const __uriData = buildUpdatePetWithFormURI({
    petId,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Updates a pet in the store with form data
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet that needs to be updated
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function updatePetWithForm(
  {
    body,
    petId,
  } : APITypes.UpdatePetWithForm.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.UpdatePetWithForm.Output>> {
  const httpRequest = buildUpdatePetWithFormInput({
    body,
    petId,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UpdatePetWithForm.Output;
}


/**
 * Build the \\"deletePet\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * Pet id to delete
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildDeletePetURI(
  {
    petId,
  } : Pick<APITypes.DeletePet.Input,
    'petId'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }

  const __pathParts = [
    'pet',
    petId,
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"deletePet\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} [parameters.apiKey],
* @param {integer} parameters.petId
 * Pet id to delete
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildDeletePetInput(
  {
    apiKey,
    petId,
  } : APITypes.DeletePet.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.deletePet;
  const __uriData = buildDeletePetURI({
    petId,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
      'api_key': apiKey,
    })),
    body: undefined,
  };
}

/**
 * Deletes a pet
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} [parameters.apiKey],
* @param {integer} parameters.petId
 * Pet id to delete
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function deletePet(
  {
    apiKey,
    petId,
  } : APITypes.DeletePet.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.DeletePet.Output>> {
  const httpRequest = buildDeletePetInput({
    apiKey,
    petId,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.DeletePet.Output;
}


/**
 * Build the \\"uploadFile\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * ID of pet to update
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildUploadFileURI(
  {
    petId,
  } : Pick<APITypes.UploadFile.Input,
    'petId'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }

  const __pathParts = [
    'pet',
    petId,
    'uploadImage',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"uploadFile\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet to update
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildUploadFileInput(
  {
    body,
    petId,
  } : APITypes.UploadFile.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.UploadFile.Input['body']> {



  const __method = APIMethods.uploadFile;
  const __uriData = buildUploadFileURI({
    petId,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * uploads an image
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet to update
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function uploadFile(
  {
    body,
    petId,
  } : APITypes.UploadFile.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.UploadFile.Output>> {
  const httpRequest = buildUploadFileInput({
    body,
    petId,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UploadFile.Output;
}


/**
 * Build the \\"getInventory\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetInventoryURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'store',
    'inventory',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getInventory\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetInventoryInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getInventory;
  const __uriData = buildGetInventoryURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Returns pet inventories by status
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getInventory(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.GetInventory.Output>> {
  const httpRequest = buildGetInventoryInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetInventory.Output;
}


/**
 * Build the \\"placeOrder\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildPlaceOrderURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'store',
    'order',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"placeOrder\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildPlaceOrderInput(
  {
    body,
  } : APITypes.PlaceOrder.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.PlaceOrder.Input['body']> {



  const __method = APIMethods.placeOrder;
  const __uriData = buildPlaceOrderURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Place an order for a pet
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function placeOrder(
  {
    body,
  } : APITypes.PlaceOrder.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.PlaceOrder.Output>> {
  const httpRequest = buildPlaceOrderInput({
    body,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.PlaceOrder.Output;
}


/**
 * Build the \\"getOrderById\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetOrderByIdURI(
  {
    orderId,
  } : Pick<APITypes.GetOrderById.Input,
    'orderId'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(orderId == null) {
    throw new Error('Missing required parameter : orderId. Value : ' +  orderId);
  }

  const __pathParts = [
    'store',
    'order',
    orderId,
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getOrderById\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetOrderByIdInput(
  {
    orderId,
  } : APITypes.GetOrderById.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getOrderById;
  const __uriData = buildGetOrderByIdURI({
    orderId,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Find purchase order by ID
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getOrderById(
  {
    orderId,
  } : APITypes.GetOrderById.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.GetOrderById.Output>> {
  const httpRequest = buildGetOrderByIdInput({
    orderId,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetOrderById.Output;
}


/**
 * Build the \\"deleteOrder\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildDeleteOrderURI(
  {
    orderId,
  } : Pick<APITypes.DeleteOrder.Input,
    'orderId'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(orderId == null) {
    throw new Error('Missing required parameter : orderId. Value : ' +  orderId);
  }

  const __pathParts = [
    'store',
    'order',
    orderId,
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"deleteOrder\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildDeleteOrderInput(
  {
    orderId,
  } : APITypes.DeleteOrder.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.deleteOrder;
  const __uriData = buildDeleteOrderURI({
    orderId,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Delete purchase order by ID
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function deleteOrder(
  {
    orderId,
  } : APITypes.DeleteOrder.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.DeleteOrder.Output>> {
  const httpRequest = buildDeleteOrderInput({
    orderId,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.DeleteOrder.Output;
}


/**
 * Build the \\"createUser\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildCreateUserURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'user',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"createUser\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildCreateUserInput(
  {
    body,
  } : APITypes.CreateUser.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.CreateUser.Input['body']> {



  const __method = APIMethods.createUser;
  const __uriData = buildCreateUserURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Create user
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function createUser(
  {
    body,
  } : APITypes.CreateUser.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.CreateUser.Output>> {
  const httpRequest = buildCreateUserInput({
    body,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.CreateUser.Output;
}


/**
 * Build the \\"createUsersWithArrayInput\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildCreateUsersWithArrayInputURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'user',
    'createWithArray',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"createUsersWithArrayInput\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildCreateUsersWithArrayInputInput(
  {
    body,
  } : APITypes.CreateUsersWithArrayInput.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.CreateUsersWithArrayInput.Input['body']> {



  const __method = APIMethods.createUsersWithArrayInput;
  const __uriData = buildCreateUsersWithArrayInputURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Creates list of users with given input array
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function createUsersWithArrayInput(
  {
    body,
  } : APITypes.CreateUsersWithArrayInput.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.CreateUsersWithArrayInput.Output>> {
  const httpRequest = buildCreateUsersWithArrayInputInput({
    body,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.CreateUsersWithArrayInput.Output;
}


/**
 * Build the \\"createUsersWithListInput\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildCreateUsersWithListInputURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'user',
    'createWithList',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"createUsersWithListInput\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildCreateUsersWithListInputInput(
  {
    body,
  } : APITypes.CreateUsersWithListInput.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.CreateUsersWithListInput.Input['body']> {



  const __method = APIMethods.createUsersWithListInput;
  const __uriData = buildCreateUsersWithListInputURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Creates list of users with given input array
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function createUsersWithListInput(
  {
    body,
  } : APITypes.CreateUsersWithListInput.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.CreateUsersWithListInput.Output>> {
  const httpRequest = buildCreateUsersWithListInputInput({
    body,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.CreateUsersWithListInput.Output;
}


/**
 * Build the \\"loginUser\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * The user name for login,
* @param {string} parameters.password
 * The password for login in clear text
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildLoginUserURI(
  {
    username,
    password,
  } : Pick<APITypes.LoginUser.Input,
    'username'|
    'password'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }
  if(password == null) {
    throw new Error('Missing required parameter : password. Value : ' +  password);
  }

  const __pathParts = [
    'user',
    'login',
  ];
  const __qs = cleanQuery({
    username: username,
    password: password,
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"loginUser\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The user name for login,
* @param {string} parameters.password
 * The password for login in clear text
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildLoginUserInput(
  {
    username,
    password,
  } : APITypes.LoginUser.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.loginUser;
  const __uriData = buildLoginUserURI({
    username,
    password,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Logs user into the system
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The user name for login,
* @param {string} parameters.password
 * The password for login in clear text
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function loginUser(
  {
    username,
    password,
  } : APITypes.LoginUser.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.LoginUser.Output>> {
  const httpRequest = buildLoginUserInput({
    username,
    password,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.LoginUser.Output;
}


/**
 * Build the \\"logoutUser\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildLogoutUserURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'user',
    'logout',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"logoutUser\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildLogoutUserInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.logoutUser;
  const __uriData = buildLogoutUserURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Logs out current logged in user session
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function logoutUser(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.LogoutUser.Output>> {
  const httpRequest = buildLogoutUserInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.LogoutUser.Output;
}


/**
 * Build the \\"getUserByName\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetUserByNameURI(
  {
    username,
  } : Pick<APITypes.GetUserByName.Input,
    'username'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }

  const __pathParts = [
    'user',
    username,
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getUserByName\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetUserByNameInput(
  {
    username,
  } : APITypes.GetUserByName.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getUserByName;
  const __uriData = buildGetUserByNameURI({
    username,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Get user by user name
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getUserByName(
  {
    username,
  } : APITypes.GetUserByName.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.GetUserByName.Output>> {
  const httpRequest = buildGetUserByNameInput({
    username,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetUserByName.Output;
}


/**
 * Build the \\"updateUser\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * name that need to be deleted
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildUpdateUserURI(
  {
    username,
  } : Pick<APITypes.UpdateUser.Input,
    'username'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }

  const __pathParts = [
    'user',
    username,
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"updateUser\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * name that need to be deleted
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildUpdateUserInput(
  {
    body,
    username,
  } : APITypes.UpdateUser.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.UpdateUser.Input['body']> {



  const __method = APIMethods.updateUser;
  const __uriData = buildUpdateUserURI({
    username,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Updated user
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * name that need to be deleted
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function updateUser(
  {
    body,
    username,
  } : APITypes.UpdateUser.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.UpdateUser.Output>> {
  const httpRequest = buildUpdateUserInput({
    body,
    username,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UpdateUser.Output;
}


/**
 * Build the \\"deleteUser\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * The name that needs to be deleted
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildDeleteUserURI(
  {
    username,
  } : Pick<APITypes.DeleteUser.Input,
    'username'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }

  const __pathParts = [
    'user',
    username,
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"deleteUser\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be deleted
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildDeleteUserInput(
  {
    username,
  } : APITypes.DeleteUser.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.deleteUser;
  const __uriData = buildDeleteUserURI({
    username,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Delete user
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be deleted
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function deleteUser(
  {
    username,
  } : APITypes.DeleteUser.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.DeleteUser.Output>> {
  const httpRequest = buildDeleteUserInput({
    username,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.DeleteUser.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with filterStatuses 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

import querystring from 'querystring';
import axios from 'axios';
import type { AxiosRequestConfig } from 'axios';

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIBuilderOptions = {
  baseURL?: string;
};
export type InputBuilderOptions = URIBuilderOptions & {
    headers?: Headers;
};
export type URIData = {
  baseURL: string;
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type { APITypes, Components };

declare namespace APITypes {
    export namespace GetPing {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getPingResponse200<200>;
        }
    }
}
declare namespace Components {
    export namespace Responses {
        type getPingResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetPingResponse200Body0;
        };
    }
    export namespace Schemas {
        export type ResponsesgetPingResponse200Body0 = NonNullable<{
            pong?: \\"pong\\";
        }>;
    }
}

const DEFAULT_BASE_URL = 'http://192.168.10.149:8000/v3';
const URI_BUILDER_DEFAULTS = {
  baseURL: DEFAULT_BASE_URL,
};
const INPUT_BUILDER_DEFAULTS = {
  baseURL: DEFAULT_BASE_URL,
  headers: {},
};

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getPing,
};

export const APIURIBuilders = {
  getPing: buildGetPingURI,
};

export const APIMethods = {
  getPing: 'get',
} as const;

export const APIInputBuilders = {
  getPing: buildGetPingInput,
};


/**
 * Build the \\"getPing\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetPingURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'ping',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getPing\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetPingInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getPing;
  const __uriData = buildGetPingURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Checks API's availability.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getPing(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.GetPing.Output>> {
  const httpRequest = buildGetPingInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetPing.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with refs 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

import querystring from 'querystring';
import axios from 'axios';
import type { AxiosRequestConfig } from 'axios';

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIBuilderOptions = {
  baseURL?: string;
};
export type InputBuilderOptions = URIBuilderOptions & {
    headers?: Headers;
};
export type URIData = {
  baseURL: string;
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type { APITypes, Components };

declare namespace APITypes {
    export namespace PutEcho {
        export type Body = Components.RequestBodies.PutEchoRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.putEchoResponse200<200>;
        }
    }
}
declare namespace Components {
    export namespace RequestBodies {
        export type PutEchoRequestBody = Components.Schemas.Echo;
    }
    export namespace Responses {
        type putEchoResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesputEchoResponse200Body0;
        };
    }
    export namespace Schemas {
        export type Echo = NonNullable<{
            echo: NonNullable<string>;
        }>;
        export type ResponsesputEchoResponse200Body0 = NonNullable<{
            echo: NonNullable<string>;
        }>;
    }
}

const DEFAULT_BASE_URL = 'http://192.168.10.149:8000/v3';
const URI_BUILDER_DEFAULTS = {
  baseURL: DEFAULT_BASE_URL,
};
const INPUT_BUILDER_DEFAULTS = {
  baseURL: DEFAULT_BASE_URL,
  headers: {},
};

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  putEcho,
};

export const APIURIBuilders = {
  putEcho: buildPutEchoURI,
};

export const APIMethods = {
  putEcho: 'put',
} as const;

export const APIInputBuilders = {
  putEcho: buildPutEchoInput,
};


/**
 * Build the \\"putEcho\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildPutEchoURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'echo',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"putEcho\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildPutEchoInput(
  {
    body,
  } : APITypes.PutEcho.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<APITypes.PutEcho.Input['body']> {



  const __method = APIMethods.putEcho;
  const __uriData = buildPutEchoURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Echoes what it takes.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function putEcho(
  {
    body,
  } : APITypes.PutEcho.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<APITypes.PutEcho.Output>> {
  const httpRequest = buildPutEchoInput({
    body,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.PutEcho.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with sdkName 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

import querystring from 'querystring';
import axios from 'axios';
import type { AxiosRequestConfig } from 'axios';

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIBuilderOptions = {
  baseURL?: string;
};
export type InputBuilderOptions = URIBuilderOptions & {
    headers?: Headers;
};
export type URIData = {
  baseURL: string;
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type { FooAPITypes, Components };

declare namespace FooAPITypes {
    export namespace GetOpenAPI {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getOpenAPIResponse200<200>;
        }
    }
    export namespace GetPing {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getPingResponse200<200>;
        }
    }
    export namespace GetDelay {
        export type Output = Responses.$204;
        export type Input = {
            readonly duration: Parameters.Duration;
            readonly cookie?: Parameters.Cookie;
            readonly xApplicationVersion?: Parameters.XApplicationVersion;
        };
        export namespace Responses {
            export type $204 = Components.Responses.getDelayResponse204<204>;
        }
        export namespace Parameters {
            export type Duration = Components.Parameters.GetDelay0;
            export type Cookie = Components.Parameters.GetDelay1;
            export type XApplicationVersion = Components.Parameters.GetDelay2;
        }
    }
    export namespace GetDiagnostic {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getDiagnosticResponse200<200>;
        }
    }
    export namespace GetTime {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getTimeResponse200<200>;
        }
    }
    export namespace PutEcho {
        export type Body = Components.RequestBodies.PutEchoRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.putEchoResponse200<200>;
        }
    }
}
declare namespace Components {
    export namespace RequestBodies {
        export type PutEchoRequestBody = Components.Schemas.RequestBodiesputEchoRequestBodyBody0;
    }
    export namespace Parameters {
        export type GetDelay0 = NonNullable<number>;
        export type GetDelay1 = NonNullable<string>;
        export type GetDelay2 = NonNullable<string>;
    }
    export namespace Responses {
        type getDelayResponse204<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getOpenAPIResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetOpenAPIResponse200Body0;
        };
        type getPingResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetPingResponse200Body0;
        };
        type getDiagnosticResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetDiagnosticResponse200Body0;
        };
        type getTimeResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetTimeResponse200Body0;
        };
        type putEchoResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesputEchoResponse200Body0;
        };
    }
    export namespace Schemas {
        export type RequestBodiesputEchoRequestBodyBody0 = NonNullable<{
            echo: NonNullable<string>;
        }>;
        export type ResponsesgetOpenAPIResponse200Body0 = NonNullable<{}>;
        export type ResponsesgetPingResponse200Body0 = NonNullable<{
            pong?: \\"pong\\";
        }>;
        export type ResponsesgetDiagnosticResponse200Body0 = NonNullable<{
            [pattern: string]: unknown;
        }>;
        export type ResponsesgetTimeResponse200Body0 = NonNullable<{
            currentDate?: NonNullable<string>;
        }>;
        export type ResponsesputEchoResponse200Body0 = NonNullable<{
            echo: NonNullable<string>;
        }>;
    }
}

const DEFAULT_BASE_URL = 'http://192.168.10.149:8000/v3';
const URI_BUILDER_DEFAULTS = {
  baseURL: DEFAULT_BASE_URL,
};
const INPUT_BUILDER_DEFAULTS = {
  baseURL: DEFAULT_BASE_URL,
  headers: {},
};

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getOpenAPI,
  getPing,
  getDelay,
  getDiagnostic,
  getTime,
  putEcho,
};

export const APIURIBuilders = {
  getOpenAPI: buildGetOpenAPIURI,
  getPing: buildGetPingURI,
  getDelay: buildGetDelayURI,
  getDiagnostic: buildGetDiagnosticURI,
  getTime: buildGetTimeURI,
  putEcho: buildPutEchoURI,
};

export const APIMethods = {
  getOpenAPI: 'get',
  getPing: 'get',
  getDelay: 'get',
  getDiagnostic: 'get',
  getTime: 'get',
  putEcho: 'put',
} as const;

export const APIInputBuilders = {
  getOpenAPI: buildGetOpenAPIInput,
  getPing: buildGetPingInput,
  getDelay: buildGetDelayInput,
  getDiagnostic: buildGetDiagnosticInput,
  getTime: buildGetTimeInput,
  putEcho: buildPutEchoInput,
};


/**
 * Build the \\"getOpenAPI\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetOpenAPIURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'openAPI',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getOpenAPI\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetOpenAPIInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getOpenAPI;
  const __uriData = buildGetOpenAPIURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Get API documentation.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getOpenAPI(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<FooAPITypes.GetOpenAPI.Output>> {
  const httpRequest = buildGetOpenAPIInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as FooAPITypes.GetOpenAPI.Output;
}


/**
 * Build the \\"getPing\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetPingURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'ping',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getPing\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetPingInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getPing;
  const __uriData = buildGetPingURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Checks API's availability.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getPing(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<FooAPITypes.GetPing.Output>> {
  const httpRequest = buildGetPingInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as FooAPITypes.GetPing.Output;
}


/**
 * Build the \\"getDelay\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetDelayURI(
  {
    duration,
  } : Pick<FooAPITypes.GetDelay.Input,
    'duration'
      >,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {
  if(duration == null) {
    throw new Error('Missing required parameter : duration. Value : ' +  duration);
  }

  const __pathParts = [
    'delay',
  ];
  const __qs = cleanQuery({
    duration: duration,
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getDelay\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetDelayInput(
  {
    duration,
    xApplicationVersion,
  } : FooAPITypes.GetDelay.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getDelay;
  const __uriData = buildGetDelayURI({
    duration,
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
      'X-Application-Version': xApplicationVersion,
    })),
    body: undefined,
  };
}

/**
 * Answer after a given delay.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getDelay(
  {
    duration,
    xApplicationVersion,
  } : FooAPITypes.GetDelay.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<FooAPITypes.GetDelay.Output>> {
  const httpRequest = buildGetDelayInput({
    duration,
    xApplicationVersion,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as FooAPITypes.GetDelay.Output;
}


/**
 * Build the \\"getDiagnostic\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetDiagnosticURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'diag',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getDiagnostic\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetDiagnosticInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getDiagnostic;
  const __uriData = buildGetDiagnosticURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Returns current API's transactions.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getDiagnostic(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<FooAPITypes.GetDiagnostic.Output>> {
  const httpRequest = buildGetDiagnosticInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as FooAPITypes.GetDiagnostic.Output;
}


/**
 * Build the \\"getTime\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildGetTimeURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'time',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"getTime\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildGetTimeInput(
  _: unknown,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<undefined> {



  const __method = APIMethods.getTime;
  const __uriData = buildGetTimeURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: undefined,
  };
}

/**
 * Get API internal clock date.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getTime(
  _: unknown,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<FooAPITypes.GetTime.Output>> {
  const httpRequest = buildGetTimeInput({
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as FooAPITypes.GetTime.Output;
}


/**
 * Build the \\"putEcho\\" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 */
function buildPutEchoURI(
  _: unknown,
  {
    baseURL: __baseURL = DEFAULT_BASE_URL,
  }: URIBuilderOptions = URI_BUILDER_DEFAULTS,
) : URIData {

  const __pathParts = [
    'echo',
  ];
  const __qs = cleanQuery({
  });

  return {
    baseURL: __baseURL,
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the \\"putEcho\\" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * The options (destructured)
 * @param {string} options.baseURL
 * The base URL of the API
 * @param {string} options.headers
 * Any additional headers to append
 */
function buildPutEchoInput(
  {
    body,
  } : FooAPITypes.PutEcho.Input,
    {
      baseURL: __baseURL = DEFAULT_BASE_URL,
      headers: __headers = {},
    }: InputBuilderOptions = INPUT_BUILDER_DEFAULTS,
) : HTTPRequest<FooAPITypes.PutEcho.Input['body']> {



  const __method = APIMethods.putEcho;
  const __uriData = buildPutEchoURI({
  }, { baseURL: __baseURL });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders(Object.assign(__headers, {
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    })),
    body: body,
  };
}

/**
 * Echoes what it takes.
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function putEcho(
  {
    body,
  } : FooAPITypes.PutEcho.Input,
  options: InputBuilderOptions & Partial<AxiosRequestConfig> = {}
) : Promise<Writeable<FooAPITypes.PutEcho.Output>> {
  const httpRequest = buildPutEchoInput({
    body,
  }, options);
  const callOptions = {
    baseURL: httpRequest.baseURL,
    method: httpRequest.method,
    url: httpRequest.path,
    headers: httpRequest.headers,
    params: httpRequest.params,
    data: httpRequest.body,
  };

  const response = await axios(Object.assign({
    ...callOptions,
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as FooAPITypes.PutEcho.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

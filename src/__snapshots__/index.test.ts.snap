// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateSDKFromOpenAPI should work 1`] = `
"// WARNING: This file is automatically generated
// by the 'openapi-ts-sed-builder' module do not
// change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;
export interface RouteTypeDefinition {
  requestBody?: unknown;
  responses?: {
    default?: {
      headers?: unknown;
      body?: unknown;
    };
    [key: number]: {
      headers?: unknown;
      body?: unknown;
    };
  };
  parameters?: {
    path?: object;
    query?: object;
    headers?: object;
    cookies?: object;
  };
}
export type RouteTypedHandler<
  T extends RouteTypeDefinition,
  O extends object = object,
> = (
  parameters: T["parameters"] &
    (T["requestBody"] extends object | string | number | boolean
      ? {
          body: T["requestBody"];
          options?: O;
        }
      : { options?: O })
) => Promise<
  {
    [Status in keyof T["responses"]]: {
      status: Status extends number ? Status : number;
    } & T["responses"][Status];
  }[keyof T["responses"]]
>;

export interface paths {
    "/openAPI": {
        "get": operations["getOpenAPI"];
    };
    "/ping": {
        "get": operations["getPing"];
    };
    "/delay": {
        "get": operations["getDelay"];
    };
    "/diag": {
        "get": operations["getDiagnostic"];
    };
    "/time": {
        "get": operations["getTime"];
    };
    "/echo": {
        put: operations["putEcho"];
    };
}
export interface operations {
    getOpenAPI: {
        responses: {
            200: {
                body: object;
            };
        };
    };
    getPing: {
        responses: {
            200: {
                body: {
                    pong?: "pong";
                };
            };
        };
    };
    getDelay: {
        responses: {
            204: object;
        };
        parameters: {
            query: {
                duration: number;
            };
            headers: {
                Cookie?: string;
                "X-Application-Version"?: string;
            };
        };
    };
    getDiagnostic: {
        responses: {
            200: {
                body: {
                    [pattern: string]: unknown;
                };
            };
        };
    };
    getTime: {
        responses: {
            200: {
                body: {
                    currentDate?: string;
                };
            };
        };
    };
    putEcho: {
        requestBody?: {
            echo: string;
        };
        responses: {
            200: {
                body: {
                    echo: string;
                };
            };
        };
    };
}

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getOpenAPI,
  getPing,
  getDelay,
  getDiagnostic,
  getTime,
  putEcho,
};

export const APIURIBuilders = {
  getOpenAPI: buildGetOpenAPIURI,
  getPing: buildGetPingURI,
  getDelay: buildGetDelayURI,
  getDiagnostic: buildGetDiagnosticURI,
  getTime: buildGetTimeURI,
  putEcho: buildPutEchoURI,
};

export const APIMethods = {
  getOpenAPI: 'get',
  getPing: 'get',
  getDelay: 'get',
  getDiagnostic: 'get',
  getTime: 'get',
  putEcho: 'put',
} as const;

export const APIStatuses = {
  getOpenAPI: [200],
  getPing: [200],
  getDelay: [204],
  getDiagnostic: [200],
  getTime: [200],
  putEcho: [200],
} as const;

export const APIInputBuilders = {
  getOpenAPI: buildGetOpenAPIInput,
  getPing: buildGetPingInput,
  getDelay: buildGetDelayInput,
  getDiagnostic: buildGetDiagnosticInput,
  getTime: buildGetTimeInput,
  putEcho: buildPutEchoInput,
};

/**
 * Build the "getOpenAPI" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetOpenAPIURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'openAPI',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getOpenAPI" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildGetOpenAPIInput(
  _: unknown,
) {



  const __method = APIMethods.getOpenAPI;
  const __uriData = buildGetOpenAPIURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Get API documentation.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getOpenAPI<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getOpenAPI"]>>>> {
  const httpRequest = buildGetOpenAPIInput({
  });

  return (await executeRequest(
    httpRequest,
    "getOpenAPI",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getOpenAPI"]>
  >>;
}

/**
 * Build the "getPing" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetPingURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'ping',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getPing" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildGetPingInput(
  _: unknown,
) {



  const __method = APIMethods.getPing;
  const __uriData = buildGetPingURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Checks API's availability.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getPing<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getPing"]>>>> {
  const httpRequest = buildGetPingInput({
  });

  return (await executeRequest(
    httpRequest,
    "getPing",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getPing"]>
  >>;
}

/**
 * Build the "getDelay" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 */
function buildGetDelayURI(
  { query } : Pick<operations["getDelay"]["parameters"], 'query'>,
) : URIData {
  if(query['duration'] == null) {
    throw new Error('Missing required parameter: "query[duration]", value : ' +  query['duration']);
  }

  const __pathParts = [
    'delay',
  ];
  const __qs = cleanQuery({
    duration: query['duration'],
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getDelay" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 */

function buildGetDelayInput(
  {
    query,
    headers,
  }: Parameters<RouteTypedHandler<operations["getDelay"]>>[0],
) {



  const __method = APIMethods.getDelay;
  const __uriData = buildGetDelayURI({ query });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
      'X-Application-Version': headers['X-Application-Version'] as string,
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Answer after a given delay.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getDelay<O>(
  executeRequest: RequestExecutor<O>,
  {
    query,
    headers,
  }: Parameters<RouteTypedHandler<operations["getDelay"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getDelay"]>>>> {
  const httpRequest = buildGetDelayInput({
    query,
    headers,
  });

  return (await executeRequest(
    httpRequest,
    "getDelay",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getDelay"]>
  >>;
}

/**
 * Build the "getDiagnostic" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetDiagnosticURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'diag',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getDiagnostic" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildGetDiagnosticInput(
  _: unknown,
) {



  const __method = APIMethods.getDiagnostic;
  const __uriData = buildGetDiagnosticURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Returns current API's transactions.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getDiagnostic<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getDiagnostic"]>>>> {
  const httpRequest = buildGetDiagnosticInput({
  });

  return (await executeRequest(
    httpRequest,
    "getDiagnostic",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getDiagnostic"]>
  >>;
}

/**
 * Build the "getTime" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetTimeURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'time',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getTime" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildGetTimeInput(
  _: unknown,
) {



  const __method = APIMethods.getTime;
  const __uriData = buildGetTimeURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Get API internal clock date.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getTime<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getTime"]>>>> {
  const httpRequest = buildGetTimeInput({
  });

  return (await executeRequest(
    httpRequest,
    "getTime",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getTime"]>
  >>;
}

/**
 * Build the "putEcho" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildPutEchoURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'echo',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "putEcho" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildPutEchoInput(
  {
    body,
  }:
    { body?: operations["putEcho"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["putEcho"]>>[0],
) {



  const __method = APIMethods.putEcho;
  const __uriData = buildPutEchoURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["putEcho"]["requestBody"]
  >;
}

/**
 * Echoes what it takes.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function putEcho<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  }:
    { body?: operations["putEcho"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["putEcho"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["putEcho"]>>>> {
  const httpRequest = buildPutEchoInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "putEcho",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["putEcho"]>
  >>;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with Pet Store 1`] = `
"// WARNING: This file is automatically generated
// by the 'openapi-ts-sed-builder' module do not
// change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;
export interface RouteTypeDefinition {
  requestBody?: unknown;
  responses?: {
    default?: {
      headers?: unknown;
      body?: unknown;
    };
    [key: number]: {
      headers?: unknown;
      body?: unknown;
    };
  };
  parameters?: {
    path?: object;
    query?: object;
    headers?: object;
    cookies?: object;
  };
}
export type RouteTypedHandler<
  T extends RouteTypeDefinition,
  O extends object = object,
> = (
  parameters: T["parameters"] &
    (T["requestBody"] extends object | string | number | boolean
      ? {
          body: T["requestBody"];
          options?: O;
        }
      : { options?: O })
) => Promise<
  {
    [Status in keyof T["responses"]]: {
      status: Status extends number ? Status : number;
    } & T["responses"][Status];
  }[keyof T["responses"]]
>;

export interface paths {
    "/pet": {
        put: operations["updatePet"];
        post: operations["addPet"];
    };
    "/pet/findByStatus": {
        "get": operations["findPetsByStatus"];
    };
    "/pet/findByTags": {
        "get": operations["findPetsByTags"];
    };
    "/pet/{petId}": {
        "get": operations["getPetById"];
        post: operations["updatePetWithForm"];
        "delete": operations["deletePet"];
    };
    "/pet/{petId}/uploadImage": {
        post: operations["uploadFile"];
    };
    "/store/inventory": {
        "get": operations["getInventory"];
    };
    "/store/order": {
        post: operations["placeOrder"];
    };
    "/store/order/{orderId}": {
        "get": operations["getOrderById"];
        "delete": operations["deleteOrder"];
    };
    "/user": {
        post: operations["createUser"];
    };
    "/user/createWithArray": {
        post: operations["createUsersWithArrayInput"];
    };
    "/user/createWithList": {
        post: operations["createUsersWithListInput"];
    };
    "/user/login": {
        "get": operations["loginUser"];
    };
    "/user/logout": {
        "get": operations["logoutUser"];
    };
    "/user/{username}": {
        "get": operations["getUserByName"];
        put: operations["updateUser"];
        "delete": operations["deleteUser"];
    };
}
export interface operations {
    updatePet: {
        requestBody: components["requestBodies"]["Pet"];
        responses: {
            400: object;
            404: object;
            405: object;
        };
    };
    addPet: {
        requestBody: components["requestBodies"]["Pet"];
        responses: {
            405: object;
        };
    };
    findPetsByStatus: {
        responses: {
            200: {
                body: components["schemas"]["Pet"][] | components["schemas"]["Pet"][];
            };
            400: object;
        };
        parameters: {
            query: {
                status: ("available" | "pending" | "sold")[];
            };
        };
    };
    findPetsByTags: {
        responses: {
            200: {
                body: components["schemas"]["Pet"][] | components["schemas"]["Pet"][];
            };
            400: object;
        };
        parameters: {
            query: {
                tags: string[];
            };
        };
    };
    getPetById: {
        responses: {
            200: {
                body: components["schemas"]["Pet"] | components["schemas"]["Pet"];
            };
            400: object;
            404: object;
        };
        parameters: {
            path: {
                petId: number;
            };
        };
    };
    updatePetWithForm: {
        requestBody?: components["schemas"]["body"];
        responses: {
            405: object;
        };
        parameters: {
            path: {
                petId: number;
            };
        };
    };
    deletePet: {
        responses: {
            400: object;
        };
        parameters: {
            headers: {
                api_key?: string;
            };
            path: {
                petId: number;
            };
        };
    };
    uploadFile: {
        requestBody?: components["schemas"]["body_1"];
        responses: {
            200: {
                body: components["schemas"]["ApiResponse"];
            };
        };
        parameters: {
            path: {
                petId: number;
            };
        };
    };
    getInventory: {
        responses: {
            200: {
                body: {
                    [pattern: string]: unknown;
                };
            };
        };
    };
    placeOrder: {
        requestBody: components["schemas"]["Order"];
        responses: {
            200: {
                body: components["schemas"]["Order"] | components["schemas"]["Order"];
            };
            400: object;
        };
    };
    getOrderById: {
        responses: {
            200: {
                body: components["schemas"]["Order"] | components["schemas"]["Order"];
            };
            400: object;
            404: object;
        };
        parameters: {
            path: {
                orderId: number;
            };
        };
    };
    deleteOrder: {
        responses: {
            400: object;
            404: object;
        };
        parameters: {
            path: {
                orderId: string;
            };
        };
    };
    createUser: {
        requestBody: components["schemas"]["User"];
        responses: {
            "default": object;
        };
    };
    createUsersWithArrayInput: {
        requestBody: components["requestBodies"]["UserArray"];
        responses: {
            "default": object;
        };
    };
    createUsersWithListInput: {
        requestBody: components["requestBodies"]["UserArray"];
        responses: {
            "default": object;
        };
    };
    loginUser: {
        responses: {
            200: {
                body: string | string;
                headers: {
                    "X-Rate-Limit"?: number;
                    "X-Expires-After"?: string;
                };
            };
            400: object;
        };
        parameters: {
            query: {
                username: string;
                password: string;
            };
        };
    };
    logoutUser: {
        responses: {
            "default": object;
        };
    };
    getUserByName: {
        responses: {
            200: {
                body: components["schemas"]["User"] | components["schemas"]["User"];
            };
            400: object;
            404: object;
        };
        parameters: {
            path: {
                username: string;
            };
        };
    };
    updateUser: {
        requestBody: components["schemas"]["User"];
        responses: {
            400: object;
            404: object;
        };
        parameters: {
            path: {
                username: string;
            };
        };
    };
    deleteUser: {
        responses: {
            400: object;
            404: object;
        };
        parameters: {
            path: {
                username: string;
            };
        };
    };
}
export interface components {
    requestBodies: {
        Pet: components["schemas"]["Pet"] | components["schemas"]["Pet"];
        UserArray: components["schemas"]["User"][];
    };
    schemas: {
        Pet: {
            id?: number;
            category?: components["schemas"]["Category"];
            name: string;
            photoUrls: string[];
            tags?: components["schemas"]["Tag"][];
            status?: Enums.Status;
        };
        body: {
            name?: string;
            status?: string;
        };
        body_1: {
            additionalMetadata?: string;
            file?: string;
        };
        ApiResponse: {
            code?: number;
            type?: string;
            message?: string;
        };
        Order: {
            id?: number;
            petId?: number;
            quantity?: number;
            shipDate?: string;
            status?: Enums.Status;
            complete?: boolean;
        };
        User: {
            id?: number;
            username?: string;
            firstName?: string;
            lastName?: string;
            email?: string;
            password?: string;
            phone?: string;
            userStatus?: number;
        };
        Category: {
            id?: number;
            name?: string;
        };
        Tag: {
            id?: number;
            name?: string;
        };
    };
}
export namespace Enums {
    export enum Status {
        Placed = "placed",
        Approved = "approved",
        Delivered = "delivered"
    }
}

/**
 * This is a sample server Petstore server. For this sample, you can use the api key \`special-key\` to test the authorization filters. For OAuth2 flow, you may use \`user\` as both username and password when asked to login.
 * @module API
 * @version 1.0.0
 */
const API = {
  updatePet,
  addPet,
  findPetsByStatus,
  findPetsByTags,
  getPetById,
  updatePetWithForm,
  deletePet,
  uploadFile,
  getInventory,
  placeOrder,
  getOrderById,
  deleteOrder,
  createUser,
  createUsersWithArrayInput,
  createUsersWithListInput,
  loginUser,
  logoutUser,
  getUserByName,
  updateUser,
  deleteUser,
};

export const APIURIBuilders = {
  updatePet: buildUpdatePetURI,
  addPet: buildAddPetURI,
  findPetsByStatus: buildFindPetsByStatusURI,
  findPetsByTags: buildFindPetsByTagsURI,
  getPetById: buildGetPetByIdURI,
  updatePetWithForm: buildUpdatePetWithFormURI,
  deletePet: buildDeletePetURI,
  uploadFile: buildUploadFileURI,
  getInventory: buildGetInventoryURI,
  placeOrder: buildPlaceOrderURI,
  getOrderById: buildGetOrderByIdURI,
  deleteOrder: buildDeleteOrderURI,
  createUser: buildCreateUserURI,
  createUsersWithArrayInput: buildCreateUsersWithArrayInputURI,
  createUsersWithListInput: buildCreateUsersWithListInputURI,
  loginUser: buildLoginUserURI,
  logoutUser: buildLogoutUserURI,
  getUserByName: buildGetUserByNameURI,
  updateUser: buildUpdateUserURI,
  deleteUser: buildDeleteUserURI,
};

export const APIMethods = {
  updatePet: 'put',
  addPet: 'post',
  findPetsByStatus: 'get',
  findPetsByTags: 'get',
  getPetById: 'get',
  updatePetWithForm: 'post',
  deletePet: 'delete',
  uploadFile: 'post',
  getInventory: 'get',
  placeOrder: 'post',
  getOrderById: 'get',
  deleteOrder: 'delete',
  createUser: 'post',
  createUsersWithArrayInput: 'post',
  createUsersWithListInput: 'post',
  loginUser: 'get',
  logoutUser: 'get',
  getUserByName: 'get',
  updateUser: 'put',
  deleteUser: 'delete',
} as const;

export const APIStatuses = {
  updatePet: [400, 404, 405],
  addPet: [405],
  findPetsByStatus: [200, 400],
  findPetsByTags: [200, 400],
  getPetById: [200, 400, 404],
  updatePetWithForm: [405],
  deletePet: [400],
  uploadFile: [200],
  getInventory: [200],
  placeOrder: [200, 400],
  getOrderById: [200, 400, 404],
  deleteOrder: [400, 404],
  createUser: ["default"],
  createUsersWithArrayInput: ["default"],
  createUsersWithListInput: ["default"],
  loginUser: [200, 400],
  logoutUser: ["default"],
  getUserByName: [200, 400, 404],
  updateUser: [400, 404],
  deleteUser: [400, 404],
} as const;

export const APIInputBuilders = {
  updatePet: buildUpdatePetInput,
  addPet: buildAddPetInput,
  findPetsByStatus: buildFindPetsByStatusInput,
  findPetsByTags: buildFindPetsByTagsInput,
  getPetById: buildGetPetByIdInput,
  updatePetWithForm: buildUpdatePetWithFormInput,
  deletePet: buildDeletePetInput,
  uploadFile: buildUploadFileInput,
  getInventory: buildGetInventoryInput,
  placeOrder: buildPlaceOrderInput,
  getOrderById: buildGetOrderByIdInput,
  deleteOrder: buildDeleteOrderInput,
  createUser: buildCreateUserInput,
  createUsersWithArrayInput: buildCreateUsersWithArrayInputInput,
  createUsersWithListInput: buildCreateUsersWithListInputInput,
  loginUser: buildLoginUserInput,
  logoutUser: buildLogoutUserInput,
  getUserByName: buildGetUserByNameInput,
  updateUser: buildUpdateUserInput,
  deleteUser: buildDeleteUserInput,
};

/**
 * Build the "updatePet" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildUpdatePetURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'pet',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "updatePet" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildUpdatePetInput(
  {
    body,
  }:
    { body?: operations["updatePet"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["updatePet"]>>[0],
) {



  const __method = APIMethods.updatePet;
  const __uriData = buildUpdatePetURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["updatePet"]["requestBody"]
  >;
}

/**
 * Update an existing pet
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function updatePet<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  }:
    { body?: operations["updatePet"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["updatePet"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["updatePet"]>>>> {
  const httpRequest = buildUpdatePetInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "updatePet",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["updatePet"]>
  >>;
}

/**
 * Build the "addPet" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildAddPetURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'pet',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "addPet" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildAddPetInput(
  {
    body,
  }:
    { body?: operations["addPet"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["addPet"]>>[0],
) {



  const __method = APIMethods.addPet;
  const __uriData = buildAddPetURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["addPet"]["requestBody"]
  >;
}

/**
 * Add a new pet to the store
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function addPet<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  }:
    { body?: operations["addPet"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["addPet"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["addPet"]>>>> {
  const httpRequest = buildAddPetInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "addPet",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["addPet"]>
  >>;
}

/**
 * Build the "findPetsByStatus" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {array} parameters.status
 * Status values that need to be considered for filter
 */
function buildFindPetsByStatusURI(
  { query } : Pick<operations["findPetsByStatus"]["parameters"], 'query'>,
) : URIData {
  if(query['status'] == null) {
    throw new Error('Missing required parameter: "query[status]", value : ' +  query['status']);
  }

  const __pathParts = [
    'pet',
    'findByStatus',
  ];
  const __qs = cleanQuery({
    status: query['status'],
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "findPetsByStatus" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.status
 * Status values that need to be considered for filter
 */

function buildFindPetsByStatusInput(
  {
    query,
  }: Parameters<RouteTypedHandler<operations["findPetsByStatus"]>>[0],
) {



  const __method = APIMethods.findPetsByStatus;
  const __uriData = buildFindPetsByStatusURI({ query });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Finds Pets by status
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.status
 * Status values that need to be considered for filter
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function findPetsByStatus<O>(
  executeRequest: RequestExecutor<O>,
  {
    query,
  }: Parameters<RouteTypedHandler<operations["findPetsByStatus"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["findPetsByStatus"]>>>> {
  const httpRequest = buildFindPetsByStatusInput({
    query,
  });

  return (await executeRequest(
    httpRequest,
    "findPetsByStatus",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["findPetsByStatus"]>
  >>;
}

/**
 * Build the "findPetsByTags" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {array} parameters.tags
 * Tags to filter by
 */
function buildFindPetsByTagsURI(
  { query } : Pick<operations["findPetsByTags"]["parameters"], 'query'>,
) : URIData {
  if(query['tags'] == null) {
    throw new Error('Missing required parameter: "query[tags]", value : ' +  query['tags']);
  }

  const __pathParts = [
    'pet',
    'findByTags',
  ];
  const __qs = cleanQuery({
    tags: query['tags'],
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "findPetsByTags" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.tags
 * Tags to filter by
 */

function buildFindPetsByTagsInput(
  {
    query,
  }: Parameters<RouteTypedHandler<operations["findPetsByTags"]>>[0],
) {



  const __method = APIMethods.findPetsByTags;
  const __uriData = buildFindPetsByTagsURI({ query });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Finds Pets by tags
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {array} parameters.tags
 * Tags to filter by
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function findPetsByTags<O>(
  executeRequest: RequestExecutor<O>,
  {
    query,
  }: Parameters<RouteTypedHandler<operations["findPetsByTags"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["findPetsByTags"]>>>> {
  const httpRequest = buildFindPetsByTagsInput({
    query,
  });

  return (await executeRequest(
    httpRequest,
    "findPetsByTags",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["findPetsByTags"]>
  >>;
}

/**
 * Build the "getPetById" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * ID of pet to return
 */
function buildGetPetByIdURI(
  { path } : Pick<operations["getPetById"]["parameters"], 'path'>,
) : URIData {
  if(path['petId'] == null) {
    throw new Error('Missing required parameter: "path[petId]", value : ' +  path['petId']);
  }

  const __pathParts = [
    'pet',
    path['petId'],
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getPetById" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet to return
 */

function buildGetPetByIdInput(
  {
    path,
  }: Parameters<RouteTypedHandler<operations["getPetById"]>>[0],
) {



  const __method = APIMethods.getPetById;
  const __uriData = buildGetPetByIdURI({ path });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Find pet by ID
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet to return
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getPetById<O>(
  executeRequest: RequestExecutor<O>,
  {
    path,
  }: Parameters<RouteTypedHandler<operations["getPetById"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getPetById"]>>>> {
  const httpRequest = buildGetPetByIdInput({
    path,
  });

  return (await executeRequest(
    httpRequest,
    "getPetById",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getPetById"]>
  >>;
}

/**
 * Build the "updatePetWithForm" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * ID of pet that needs to be updated
 */
function buildUpdatePetWithFormURI(
  { path } : Pick<operations["updatePetWithForm"]["parameters"], 'path'>,
) : URIData {
  if(path['petId'] == null) {
    throw new Error('Missing required parameter: "path[petId]", value : ' +  path['petId']);
  }

  const __pathParts = [
    'pet',
    path['petId'],
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "updatePetWithForm" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet that needs to be updated
 */

function buildUpdatePetWithFormInput(
  {
    body,
    path,
  }:
    { body?: operations["updatePetWithForm"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["updatePetWithForm"]>>[0],
) {



  const __method = APIMethods.updatePetWithForm;
  const __uriData = buildUpdatePetWithFormURI({ path });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["updatePetWithForm"]["requestBody"]
  >;
}

/**
 * Updates a pet in the store with form data
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
* @param {integer} parameters.petId
 * ID of pet that needs to be updated
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function updatePetWithForm<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
    path,
  }:
    { body?: operations["updatePetWithForm"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["updatePetWithForm"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["updatePetWithForm"]>>>> {
  const httpRequest = buildUpdatePetWithFormInput({
    body,
    path,
  });

  return (await executeRequest(
    httpRequest,
    "updatePetWithForm",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["updatePetWithForm"]>
  >>;
}

/**
 * Build the "deletePet" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * Pet id to delete
 */
function buildDeletePetURI(
  { path } : Pick<operations["deletePet"]["parameters"], 'path'>,
) : URIData {
  if(path['petId'] == null) {
    throw new Error('Missing required parameter: "path[petId]", value : ' +  path['petId']);
  }

  const __pathParts = [
    'pet',
    path['petId'],
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "deletePet" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} [parameters.apiKey],
* @param {integer} parameters.petId
 * Pet id to delete
 */

function buildDeletePetInput(
  {
    headers,
    path,
  }: Parameters<RouteTypedHandler<operations["deletePet"]>>[0],
) {



  const __method = APIMethods.deletePet;
  const __uriData = buildDeletePetURI({ path });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
      'api_key': headers['api_key'] as string,
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Deletes a pet
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} [parameters.apiKey],
* @param {integer} parameters.petId
 * Pet id to delete
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function deletePet<O>(
  executeRequest: RequestExecutor<O>,
  {
    headers,
    path,
  }: Parameters<RouteTypedHandler<operations["deletePet"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["deletePet"]>>>> {
  const httpRequest = buildDeletePetInput({
    headers,
    path,
  });

  return (await executeRequest(
    httpRequest,
    "deletePet",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["deletePet"]>
  >>;
}

/**
 * Build the "uploadFile" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.petId
 * ID of pet to update
 */
function buildUploadFileURI(
  { path } : Pick<operations["uploadFile"]["parameters"], 'path'>,
) : URIData {
  if(path['petId'] == null) {
    throw new Error('Missing required parameter: "path[petId]", value : ' +  path['petId']);
  }

  const __pathParts = [
    'pet',
    path['petId'],
    'uploadImage',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "uploadFile" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.petId
 * ID of pet to update
 */

function buildUploadFileInput(
  {
    body,
    path,
  }:
    { body?: operations["uploadFile"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["uploadFile"]>>[0],
) {



  const __method = APIMethods.uploadFile;
  const __uriData = buildUploadFileURI({ path });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["uploadFile"]["requestBody"]
  >;
}

/**
 * uploads an image
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
* @param {integer} parameters.petId
 * ID of pet to update
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function uploadFile<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
    path,
  }:
    { body?: operations["uploadFile"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["uploadFile"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["uploadFile"]>>>> {
  const httpRequest = buildUploadFileInput({
    body,
    path,
  });

  return (await executeRequest(
    httpRequest,
    "uploadFile",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["uploadFile"]>
  >>;
}

/**
 * Build the "getInventory" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetInventoryURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'store',
    'inventory',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getInventory" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildGetInventoryInput(
  _: unknown,
) {



  const __method = APIMethods.getInventory;
  const __uriData = buildGetInventoryURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Returns pet inventories by status
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getInventory<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getInventory"]>>>> {
  const httpRequest = buildGetInventoryInput({
  });

  return (await executeRequest(
    httpRequest,
    "getInventory",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getInventory"]>
  >>;
}

/**
 * Build the "placeOrder" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildPlaceOrderURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'store',
    'order',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "placeOrder" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildPlaceOrderInput(
  {
    body,
  }:
    { body?: operations["placeOrder"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["placeOrder"]>>[0],
) {



  const __method = APIMethods.placeOrder;
  const __uriData = buildPlaceOrderURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["placeOrder"]["requestBody"]
  >;
}

/**
 * Place an order for a pet
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function placeOrder<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  }:
    { body?: operations["placeOrder"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["placeOrder"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["placeOrder"]>>>> {
  const httpRequest = buildPlaceOrderInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "placeOrder",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["placeOrder"]>
  >>;
}

/**
 * Build the "getOrderById" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 */
function buildGetOrderByIdURI(
  { path } : Pick<operations["getOrderById"]["parameters"], 'path'>,
) : URIData {
  if(path['orderId'] == null) {
    throw new Error('Missing required parameter: "path[orderId]", value : ' +  path['orderId']);
  }

  const __pathParts = [
    'store',
    'order',
    path['orderId'],
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getOrderById" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 */

function buildGetOrderByIdInput(
  {
    path,
  }: Parameters<RouteTypedHandler<operations["getOrderById"]>>[0],
) {



  const __method = APIMethods.getOrderById;
  const __uriData = buildGetOrderByIdURI({ path });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Find purchase order by ID
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getOrderById<O>(
  executeRequest: RequestExecutor<O>,
  {
    path,
  }: Parameters<RouteTypedHandler<operations["getOrderById"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getOrderById"]>>>> {
  const httpRequest = buildGetOrderByIdInput({
    path,
  });

  return (await executeRequest(
    httpRequest,
    "getOrderById",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getOrderById"]>
  >>;
}

/**
 * Build the "deleteOrder" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 */
function buildDeleteOrderURI(
  { path } : Pick<operations["deleteOrder"]["parameters"], 'path'>,
) : URIData {
  if(path['orderId'] == null) {
    throw new Error('Missing required parameter: "path[orderId]", value : ' +  path['orderId']);
  }

  const __pathParts = [
    'store',
    'order',
    path['orderId'],
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "deleteOrder" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 */

function buildDeleteOrderInput(
  {
    path,
  }: Parameters<RouteTypedHandler<operations["deleteOrder"]>>[0],
) {



  const __method = APIMethods.deleteOrder;
  const __uriData = buildDeleteOrderURI({ path });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Delete purchase order by ID
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function deleteOrder<O>(
  executeRequest: RequestExecutor<O>,
  {
    path,
  }: Parameters<RouteTypedHandler<operations["deleteOrder"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["deleteOrder"]>>>> {
  const httpRequest = buildDeleteOrderInput({
    path,
  });

  return (await executeRequest(
    httpRequest,
    "deleteOrder",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["deleteOrder"]>
  >>;
}

/**
 * Build the "createUser" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildCreateUserURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'user',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "createUser" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildCreateUserInput(
  {
    body,
  }:
    { body?: operations["createUser"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["createUser"]>>[0],
) {



  const __method = APIMethods.createUser;
  const __uriData = buildCreateUserURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["createUser"]["requestBody"]
  >;
}

/**
 * Create user
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function createUser<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  }:
    { body?: operations["createUser"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["createUser"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["createUser"]>>>> {
  const httpRequest = buildCreateUserInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "createUser",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["createUser"]>
  >>;
}

/**
 * Build the "createUsersWithArrayInput" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildCreateUsersWithArrayInputURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'user',
    'createWithArray',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "createUsersWithArrayInput" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildCreateUsersWithArrayInputInput(
  {
    body,
  }:
    { body?: operations["createUsersWithArrayInput"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["createUsersWithArrayInput"]>>[0],
) {



  const __method = APIMethods.createUsersWithArrayInput;
  const __uriData = buildCreateUsersWithArrayInputURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["createUsersWithArrayInput"]["requestBody"]
  >;
}

/**
 * Creates list of users with given input array
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function createUsersWithArrayInput<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  }:
    { body?: operations["createUsersWithArrayInput"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["createUsersWithArrayInput"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["createUsersWithArrayInput"]>>>> {
  const httpRequest = buildCreateUsersWithArrayInputInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "createUsersWithArrayInput",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["createUsersWithArrayInput"]>
  >>;
}

/**
 * Build the "createUsersWithListInput" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildCreateUsersWithListInputURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'user',
    'createWithList',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "createUsersWithListInput" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildCreateUsersWithListInputInput(
  {
    body,
  }:
    { body?: operations["createUsersWithListInput"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["createUsersWithListInput"]>>[0],
) {



  const __method = APIMethods.createUsersWithListInput;
  const __uriData = buildCreateUsersWithListInputURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["createUsersWithListInput"]["requestBody"]
  >;
}

/**
 * Creates list of users with given input array
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function createUsersWithListInput<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  }:
    { body?: operations["createUsersWithListInput"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["createUsersWithListInput"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["createUsersWithListInput"]>>>> {
  const httpRequest = buildCreateUsersWithListInputInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "createUsersWithListInput",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["createUsersWithListInput"]>
  >>;
}

/**
 * Build the "loginUser" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * The user name for login,
* @param {string} parameters.password
 * The password for login in clear text
 */
function buildLoginUserURI(
  { query } : Pick<operations["loginUser"]["parameters"], 'query'>,
) : URIData {
  if(query['username'] == null) {
    throw new Error('Missing required parameter: "query[username]", value : ' +  query['username']);
  }
  if(query['password'] == null) {
    throw new Error('Missing required parameter: "query[password]", value : ' +  query['password']);
  }

  const __pathParts = [
    'user',
    'login',
  ];
  const __qs = cleanQuery({
    username: query['username'],
    password: query['password'],
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "loginUser" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The user name for login,
* @param {string} parameters.password
 * The password for login in clear text
 */

function buildLoginUserInput(
  {
    query,
  }: Parameters<RouteTypedHandler<operations["loginUser"]>>[0],
) {



  const __method = APIMethods.loginUser;
  const __uriData = buildLoginUserURI({ query });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Logs user into the system
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The user name for login,
* @param {string} parameters.password
 * The password for login in clear text
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function loginUser<O>(
  executeRequest: RequestExecutor<O>,
  {
    query,
  }: Parameters<RouteTypedHandler<operations["loginUser"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["loginUser"]>>>> {
  const httpRequest = buildLoginUserInput({
    query,
  });

  return (await executeRequest(
    httpRequest,
    "loginUser",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["loginUser"]>
  >>;
}

/**
 * Build the "logoutUser" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildLogoutUserURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'user',
    'logout',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "logoutUser" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildLogoutUserInput(
  _: unknown,
) {



  const __method = APIMethods.logoutUser;
  const __uriData = buildLogoutUserURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Logs out current logged in user session
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function logoutUser<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["logoutUser"]>>>> {
  const httpRequest = buildLogoutUserInput({
  });

  return (await executeRequest(
    httpRequest,
    "logoutUser",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["logoutUser"]>
  >>;
}

/**
 * Build the "getUserByName" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 */
function buildGetUserByNameURI(
  { path } : Pick<operations["getUserByName"]["parameters"], 'path'>,
) : URIData {
  if(path['username'] == null) {
    throw new Error('Missing required parameter: "path[username]", value : ' +  path['username']);
  }

  const __pathParts = [
    'user',
    path['username'],
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getUserByName" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 */

function buildGetUserByNameInput(
  {
    path,
  }: Parameters<RouteTypedHandler<operations["getUserByName"]>>[0],
) {



  const __method = APIMethods.getUserByName;
  const __uriData = buildGetUserByNameURI({ path });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Get user by user name
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getUserByName<O>(
  executeRequest: RequestExecutor<O>,
  {
    path,
  }: Parameters<RouteTypedHandler<operations["getUserByName"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getUserByName"]>>>> {
  const httpRequest = buildGetUserByNameInput({
    path,
  });

  return (await executeRequest(
    httpRequest,
    "getUserByName",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getUserByName"]>
  >>;
}

/**
 * Build the "updateUser" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * name that need to be deleted
 */
function buildUpdateUserURI(
  { path } : Pick<operations["updateUser"]["parameters"], 'path'>,
) : URIData {
  if(path['username'] == null) {
    throw new Error('Missing required parameter: "path[username]", value : ' +  path['username']);
  }

  const __pathParts = [
    'user',
    path['username'],
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "updateUser" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * name that need to be deleted
 */

function buildUpdateUserInput(
  {
    body,
    path,
  }:
    { body?: operations["updateUser"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["updateUser"]>>[0],
) {



  const __method = APIMethods.updateUser;
  const __uriData = buildUpdateUserURI({ path });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["updateUser"]["requestBody"]
  >;
}

/**
 * Updated user
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
* @param {string} parameters.username
 * name that need to be deleted
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function updateUser<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
    path,
  }:
    { body?: operations["updateUser"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["updateUser"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["updateUser"]>>>> {
  const httpRequest = buildUpdateUserInput({
    body,
    path,
  });

  return (await executeRequest(
    httpRequest,
    "updateUser",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["updateUser"]>
  >>;
}

/**
 * Build the "deleteUser" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {string} parameters.username
 * The name that needs to be deleted
 */
function buildDeleteUserURI(
  { path } : Pick<operations["deleteUser"]["parameters"], 'path'>,
) : URIData {
  if(path['username'] == null) {
    throw new Error('Missing required parameter: "path[username]", value : ' +  path['username']);
  }

  const __pathParts = [
    'user',
    path['username'],
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "deleteUser" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be deleted
 */

function buildDeleteUserInput(
  {
    path,
  }: Parameters<RouteTypedHandler<operations["deleteUser"]>>[0],
) {



  const __method = APIMethods.deleteUser;
  const __uriData = buildDeleteUserURI({ path });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '1.0.0',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Delete user
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} parameters.username
 * The name that needs to be deleted
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function deleteUser<O>(
  executeRequest: RequestExecutor<O>,
  {
    path,
  }: Parameters<RouteTypedHandler<operations["deleteUser"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["deleteUser"]>>>> {
  const httpRequest = buildDeleteUserInput({
    path,
  });

  return (await executeRequest(
    httpRequest,
    "deleteUser",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["deleteUser"]>
  >>;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with filterStatuses 1`] = `
"// WARNING: This file is automatically generated
// by the 'openapi-ts-sed-builder' module do not
// change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;
export interface RouteTypeDefinition {
  requestBody?: unknown;
  responses?: {
    default?: {
      headers?: unknown;
      body?: unknown;
    };
    [key: number]: {
      headers?: unknown;
      body?: unknown;
    };
  };
  parameters?: {
    path?: object;
    query?: object;
    headers?: object;
    cookies?: object;
  };
}
export type RouteTypedHandler<
  T extends RouteTypeDefinition,
  O extends object = object,
> = (
  parameters: T["parameters"] &
    (T["requestBody"] extends object | string | number | boolean
      ? {
          body: T["requestBody"];
          options?: O;
        }
      : { options?: O })
) => Promise<
  {
    [Status in keyof T["responses"]]: {
      status: Status extends number ? Status : number;
    } & T["responses"][Status];
  }[keyof T["responses"]]
>;

export interface paths {
    "/ping": {
        "get": operations["getPing"];
    };
}
export interface operations {
    getPing: {
        responses: {
            200: {
                body: {
                    pong?: "pong";
                };
            };
        };
        parameters: {
            headers: {
                cookie?: components["parameters"]["cookie"];
            };
        };
    };
}
export interface components {
    parameters: {
        cookie: string;
    };
}

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getPing,
};

export const APIURIBuilders = {
  getPing: buildGetPingURI,
};

export const APIMethods = {
  getPing: 'get',
} as const;

export const APIStatuses = {
  getPing: [200, 400],
} as const;

export const APIInputBuilders = {
  getPing: buildGetPingInput,
};

/**
 * Build the "getPing" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetPingURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'ping',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getPing" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} [parameters.cookie]
 */

function buildGetPingInput(
  {
    headers,
  }: Parameters<RouteTypedHandler<operations["getPing"]>>[0],
) {



  const __method = APIMethods.getPing;
  const __uriData = buildGetPingURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
      'cookie': headers['cookie'] as string,
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Checks API's availability.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {string} [parameters.cookie]
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getPing<O>(
  executeRequest: RequestExecutor<O>,
  {
    headers,
  }: Parameters<RouteTypedHandler<operations["getPing"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getPing"]>>>> {
  const httpRequest = buildGetPingInput({
    headers,
  });

  return (await executeRequest(
    httpRequest,
    "getPing",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getPing"]>
  >>;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with refs 1`] = `
"// WARNING: This file is automatically generated
// by the 'openapi-ts-sed-builder' module do not
// change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;
export interface RouteTypeDefinition {
  requestBody?: unknown;
  responses?: {
    default?: {
      headers?: unknown;
      body?: unknown;
    };
    [key: number]: {
      headers?: unknown;
      body?: unknown;
    };
  };
  parameters?: {
    path?: object;
    query?: object;
    headers?: object;
    cookies?: object;
  };
}
export type RouteTypedHandler<
  T extends RouteTypeDefinition,
  O extends object = object,
> = (
  parameters: T["parameters"] &
    (T["requestBody"] extends object | string | number | boolean
      ? {
          body: T["requestBody"];
          options?: O;
        }
      : { options?: O })
) => Promise<
  {
    [Status in keyof T["responses"]]: {
      status: Status extends number ? Status : number;
    } & T["responses"][Status];
  }[keyof T["responses"]]
>;

export interface paths {
    "/echo": {
        put: operations["putEcho"];
    };
}
export interface operations {
    putEcho: {
        requestBody?: components["schemas"]["Echo"];
        responses: {
            200: {
                body: {
                    echo: string;
                };
            };
        };
    };
}
export interface components {
    schemas: {
        Echo: {
            echo: string;
        };
    };
}

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  putEcho,
};

export const APIURIBuilders = {
  putEcho: buildPutEchoURI,
};

export const APIMethods = {
  putEcho: 'put',
} as const;

export const APIStatuses = {
  putEcho: [200],
} as const;

export const APIInputBuilders = {
  putEcho: buildPutEchoInput,
};

/**
 * Build the "putEcho" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildPutEchoURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'echo',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "putEcho" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildPutEchoInput(
  {
    body,
  }:
    { body?: operations["putEcho"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["putEcho"]>>[0],
) {



  const __method = APIMethods.putEcho;
  const __uriData = buildPutEchoURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["putEcho"]["requestBody"]
  >;
}

/**
 * Echoes what it takes.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function putEcho<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  }:
    { body?: operations["putEcho"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["putEcho"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["putEcho"]>>>> {
  const httpRequest = buildPutEchoInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "putEcho",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["putEcho"]>
  >>;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with sdkName 1`] = `
"// WARNING: This file is automatically generated
// by the 'openapi-ts-sed-builder' module do not
// change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
export type Method = 'options' | 'get' | 'head' |'post' | 'put' | 'patch' | 'delete';
export type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
export type Headers = Record<string, string>;
export type URIData = {
  path: string;
  params: QueryParams;
};
export type HTTPRequest<T> = URIData & {
  method: Method;
  headers: Headers;
  body: T;
};
export type HTTPResponse<T> = {
  status: number;
  headers: Headers;
  body: T;
};
export type RequestExecutor<O, T = unknown, U = unknown> = (
  request: HTTPRequest<T>,
  operationId: string,
  options: O,
) => Promise<HTTPResponse<U>>;
export interface RouteTypeDefinition {
  requestBody?: unknown;
  responses?: {
    default?: {
      headers?: unknown;
      body?: unknown;
    };
    [key: number]: {
      headers?: unknown;
      body?: unknown;
    };
  };
  parameters?: {
    path?: object;
    query?: object;
    headers?: object;
    cookies?: object;
  };
}
export type RouteTypedHandler<
  T extends RouteTypeDefinition,
  O extends object = object,
> = (
  parameters: T["parameters"] &
    (T["requestBody"] extends object | string | number | boolean
      ? {
          body: T["requestBody"];
          options?: O;
        }
      : { options?: O })
) => Promise<
  {
    [Status in keyof T["responses"]]: {
      status: Status extends number ? Status : number;
    } & T["responses"][Status];
  }[keyof T["responses"]]
>;

export interface paths {
    "/openAPI": {
        "get": operations["getOpenAPI"];
    };
    "/ping": {
        "get": operations["getPing"];
    };
    "/delay": {
        "get": operations["getDelay"];
    };
    "/diag": {
        "get": operations["getDiagnostic"];
    };
    "/time": {
        "get": operations["getTime"];
    };
    "/echo": {
        put: operations["putEcho"];
    };
}
export interface operations {
    getOpenAPI: {
        responses: {
            200: {
                body: object;
            };
        };
    };
    getPing: {
        responses: {
            200: {
                body: {
                    pong?: "pong";
                };
            };
        };
    };
    getDelay: {
        responses: {
            204: object;
        };
        parameters: {
            query: {
                duration: number;
            };
            headers: {
                Cookie?: string;
                "X-Application-Version"?: string;
            };
        };
    };
    getDiagnostic: {
        responses: {
            200: {
                body: {
                    [pattern: string]: unknown;
                };
            };
        };
    };
    getTime: {
        responses: {
            200: {
                body: {
                    currentDate?: string;
                };
            };
        };
    };
    putEcho: {
        requestBody?: {
            echo: string;
        };
        responses: {
            200: {
                body: {
                    echo: string;
                };
            };
        };
    };
}

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getOpenAPI,
  getPing,
  getDelay,
  getDiagnostic,
  getTime,
  putEcho,
};

export const APIURIBuilders = {
  getOpenAPI: buildGetOpenAPIURI,
  getPing: buildGetPingURI,
  getDelay: buildGetDelayURI,
  getDiagnostic: buildGetDiagnosticURI,
  getTime: buildGetTimeURI,
  putEcho: buildPutEchoURI,
};

export const APIMethods = {
  getOpenAPI: 'get',
  getPing: 'get',
  getDelay: 'get',
  getDiagnostic: 'get',
  getTime: 'get',
  putEcho: 'put',
} as const;

export const APIStatuses = {
  getOpenAPI: [200],
  getPing: [200],
  getDelay: [204],
  getDiagnostic: [200],
  getTime: [200],
  putEcho: [200],
} as const;

export const APIInputBuilders = {
  getOpenAPI: buildGetOpenAPIInput,
  getPing: buildGetPingInput,
  getDelay: buildGetDelayInput,
  getDiagnostic: buildGetDiagnosticInput,
  getTime: buildGetTimeInput,
  putEcho: buildPutEchoInput,
};

/**
 * Build the "getOpenAPI" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetOpenAPIURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'openAPI',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getOpenAPI" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildGetOpenAPIInput(
  _: unknown,
) {



  const __method = APIMethods.getOpenAPI;
  const __uriData = buildGetOpenAPIURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Get API documentation.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getOpenAPI<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getOpenAPI"]>>>> {
  const httpRequest = buildGetOpenAPIInput({
  });

  return (await executeRequest(
    httpRequest,
    "getOpenAPI",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getOpenAPI"]>
  >>;
}

/**
 * Build the "getPing" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetPingURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'ping',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getPing" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildGetPingInput(
  _: unknown,
) {



  const __method = APIMethods.getPing;
  const __uriData = buildGetPingURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Checks API's availability.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getPing<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getPing"]>>>> {
  const httpRequest = buildGetPingInput({
  });

  return (await executeRequest(
    httpRequest,
    "getPing",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getPing"]>
  >>;
}

/**
 * Build the "getDelay" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 */
function buildGetDelayURI(
  { query } : Pick<operations["getDelay"]["parameters"], 'query'>,
) : URIData {
  if(query['duration'] == null) {
    throw new Error('Missing required parameter: "query[duration]", value : ' +  query['duration']);
  }

  const __pathParts = [
    'delay',
  ];
  const __qs = cleanQuery({
    duration: query['duration'],
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getDelay" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 */

function buildGetDelayInput(
  {
    query,
    headers,
  }: Parameters<RouteTypedHandler<operations["getDelay"]>>[0],
) {



  const __method = APIMethods.getDelay;
  const __uriData = buildGetDelayURI({ query });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
      'X-Application-Version': headers['X-Application-Version'] as string,
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Answer after a given delay.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
* @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getDelay<O>(
  executeRequest: RequestExecutor<O>,
  {
    query,
    headers,
  }: Parameters<RouteTypedHandler<operations["getDelay"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getDelay"]>>>> {
  const httpRequest = buildGetDelayInput({
    query,
    headers,
  });

  return (await executeRequest(
    httpRequest,
    "getDelay",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getDelay"]>
  >>;
}

/**
 * Build the "getDiagnostic" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetDiagnosticURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'diag',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getDiagnostic" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildGetDiagnosticInput(
  _: unknown,
) {



  const __method = APIMethods.getDiagnostic;
  const __uriData = buildGetDiagnosticURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Returns current API's transactions.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getDiagnostic<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getDiagnostic"]>>>> {
  const httpRequest = buildGetDiagnosticInput({
  });

  return (await executeRequest(
    httpRequest,
    "getDiagnostic",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getDiagnostic"]>
  >>;
}

/**
 * Build the "getTime" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildGetTimeURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'time',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "getTime" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildGetTimeInput(
  _: unknown,
) {



  const __method = APIMethods.getTime;
  const __uriData = buildGetTimeURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: undefined,
  } as HTTPRequest<undefined>;
}

/**
 * Get API internal clock date.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function getTime<O>(
  executeRequest: RequestExecutor<O>,
  _: unknown,
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["getTime"]>>>> {
  const httpRequest = buildGetTimeInput({
  });

  return (await executeRequest(
    httpRequest,
    "getTime",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["getTime"]>
  >>;
}

/**
 * Build the "putEcho" URI parameters$
 * @return {Object}
 * The object describing the built URI
 * @param {Object} parameters
 * The parameters provided to build the URI (destructured)
 */
function buildPutEchoURI(
  _: unknown,
) : URIData {

  const __pathParts = [
    'echo',
  ];
  const __qs = cleanQuery({
  });

  return {
    path: __pathParts.join('/'),
    params: __qs,
  };
}

/**
 * Build all the "putEcho" parameters
 * @return {Object}
 * The object describing the built parameters
 * @param {Object} body
 * The request body
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 */

function buildPutEchoInput(
  {
    body,
  }:
    { body?: operations["putEcho"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["putEcho"]>>[0],
) {



  const __method = APIMethods.putEcho;
  const __uriData = buildPutEchoURI({  });

  return {
    method: __method,
    ...__uriData,
    headers: cleanHeaders({
      'X-API-Version': '3.1.3',
      'X-SDK-Version': '1.0.0',
    }),
    body: body,
  } as HTTPRequest<
    operations["putEcho"]["requestBody"]
  >;
}

/**
 * Echoes what it takes.
 * @return {Object}
 * The object describing the built parameters
 * @param {Function} executeRequest
 * An asynchronous function to effectively run the request
 * @param {Object} parameters
 * The parameters provided to build them (destructured)
 * @param {Object} parameters.body
 * The request body
 * @param {Object} [options]
 * Eventual options for the request execution
 * @return {Object}
 * The HTTP response
 */
async function putEcho<O>(
  executeRequest: RequestExecutor<O>,
  {
    body,
  }:
    { body?: operations["putEcho"]["requestBody"] } &
    Parameters<RouteTypedHandler<operations["putEcho"]>>[0],
  options: O,
): Promise<Awaited<ReturnType<RouteTypedHandler<operations["putEcho"]>>>> {
  const httpRequest = buildPutEchoInput({
    body,
  });

  return (await executeRequest(
    httpRequest,
    "putEcho",
    options,
  )) as Awaited<ReturnType<
    RouteTypedHandler<operations["putEcho"]>
  >>;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => "undefined" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => "undefined" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

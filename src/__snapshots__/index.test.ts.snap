// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateSDKFromOpenAPI should work 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
type QueryParams = {
  [name: string]: string | number | string[] | number[];
};
type Headers = Record<string, string>;

declare namespace APITypes {
    export namespace GetOpenAPI {
        export type Input = {};
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.GetOpenAPI.Response200.Schema0;
        }
    }
    export namespace GetPing {
        export type Input = {};
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.GetPing.Response200.Schema0;
        }
    }
    export namespace GetDelay {
        export type Input = {
            readonly duration: Parameters.Duration;
            readonly cookie?: Parameters.Cookie;
            readonly xApplicationVersion?: Parameters.XApplicationVersion;
        };
        export type Output = any;
        export namespace Parameters {
            export type Duration = NonNullable<number>;
            export type Cookie = NonNullable<string>;
            export type XApplicationVersion = NonNullable<string>;
        }
    }
    export namespace GetDiagnostic {
        export type Input = {};
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.GetDiagnostic.Response200.Schema0;
        }
    }
    export namespace GetTime {
        export type Input = {};
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.GetTime.Response200.Schema0;
        }
    }
    export namespace PutEcho {
        export type Body = Components.Schemas.ApiRequestBodies.PutEcho.Body0;
        export type Input = {
            readonly body?: Body;
        };
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.PutEcho.Response200.Schema0;
        }
    }
}
declare namespace Components {
    export namespace Schemas {
        export namespace ApiResponses {
            export namespace GetOpenAPI {
                export namespace Response200 {
                    export type Schema0 = NonNullable<{}>;
                }
            }
            export namespace GetPing {
                export namespace Response200 {
                    export type Schema0 = NonNullable<{
                        pong?: \\"pong\\";
                    }>;
                }
            }
            export namespace GetDiagnostic {
                export namespace Response200 {
                    export type Schema0 = NonNullable<{
                        [pattern: string]: any;
                    }>;
                }
            }
            export namespace GetTime {
                export namespace Response200 {
                    export type Schema0 = NonNullable<{
                        currentDate?: NonNullable<string>;
                    }>;
                }
            }
            export namespace PutEcho {
                export namespace Response200 {
                    export type Schema0 = NonNullable<{
                        echo: NonNullable<string>;
                    }>;
                }
            }
        }
        export namespace ApiRequestBodies {
            export namespace PutEcho {
                export type Body0 = NonNullable<{
                    echo: NonNullable<string>;
                }>;
            }
        }
    }
}

import type { AxiosRequestConfig } from 'axios';
import querystring from 'querystring';
import axios from 'axios';

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getOpenAPI,
  getPing,
  getDelay,
  getDiagnostic,
  getTime,
  putEcho,
};


/**
 * Get API documentation.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getOpenAPI(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetOpenAPI.Output>> {



  const method = 'get';
  const urlParts = [
    'openAPI',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetOpenAPI.Output;
}

/**
 * Checks API's availability.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getPing(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetPing.Output>> {



  const method = 'get';
  const urlParts = [
    'ping',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetPing.Output;
}

/**
 * Answer after a given delay.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getDelay(
  {
  duration,
  xApplicationVersion,
  } : APITypes.GetDelay.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetDelay.Output>> {


  if( duration == null) {
    throw new Error('Missing required parameter : duration. Value : ' +  duration);
  }


  const method = 'get';
  const urlParts = [
    'delay',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
    'X-Application-Version': xApplicationVersion,
  });
  const qs = cleanQuery({
    duration: duration,
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetDelay.Output;
}

/**
 * Returns current API's transactions.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getDiagnostic(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetDiagnostic.Output>> {



  const method = 'get';
  const urlParts = [
    'diag',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetDiagnostic.Output;
}

/**
 * Get API internal clock date.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getTime(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetTime.Output>> {



  const method = 'get';
  const urlParts = [
    'time',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetTime.Output;
}

/**
 * Echoes what it takes.
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function putEcho(
  {
    body,
  } : APITypes.PutEcho.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.PutEcho.Output>> {



  const method = 'put';
  const urlParts = [
    'echo',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.PutEcho.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {});
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {});
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with Pet Store 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
type QueryParams = {
  [name: string]: string | number | string[] | number[];
};
type Headers = Record<string, string>;

declare namespace APITypes {
    export namespace UpdatePet {
        export type Body = Components.Schemas.ApiRequestBodies.UpdatePet.Body0 | Components.Schemas.ApiRequestBodies.UpdatePet.Body1;
        export type Input = {
            readonly body: Body;
        };
        export type Output = any;
    }
    export namespace AddPet {
        export type Body = Components.Schemas.ApiRequestBodies.AddPet.Body0 | Components.Schemas.ApiRequestBodies.AddPet.Body1;
        export type Input = {
            readonly body: Body;
        };
        export type Output = any;
    }
    export namespace FindPetsByStatus {
        export type Input = {
            readonly status: Parameters.Status;
        };
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.FindPetsByStatus.Response200.Schema0 | Components.Schemas.ApiResponses.FindPetsByStatus.Response200.Schema1;
        }
        export namespace Parameters {
            export type Status = NonNullable<(\\"available\\" | \\"pending\\" | \\"sold\\")[]>;
        }
    }
    export namespace FindPetsByTags {
        export type Input = {
            readonly tags: Parameters.Tags;
        };
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.FindPetsByTags.Response200.Schema0 | Components.Schemas.ApiResponses.FindPetsByTags.Response200.Schema1;
        }
        export namespace Parameters {
            export type Tags = NonNullable<NonNullable<string>[]>;
        }
    }
    export namespace GetPetById {
        export type Input = {
            readonly petId: Parameters.PetId;
        };
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.GetPetById.Response200.Schema0 | Components.Schemas.ApiResponses.GetPetById.Response200.Schema1;
        }
        export namespace Parameters {
            export type PetId = NonNullable<number>;
        }
    }
    export namespace UpdatePetWithForm {
        export type Body = Components.Schemas.ApiRequestBodies.UpdatePetWithForm.Body0;
        export type Input = {
            readonly body?: Body;
            readonly petId: Parameters.PetId;
        };
        export type Output = any;
        export namespace Parameters {
            export type PetId = NonNullable<number>;
        }
    }
    export namespace DeletePet {
        export type Input = {
            readonly apiKey?: Parameters.ApiKey;
            readonly petId: Parameters.PetId;
        };
        export type Output = any;
        export namespace Parameters {
            export type ApiKey = NonNullable<string>;
            export type PetId = NonNullable<number>;
        }
    }
    export namespace UploadFile {
        export type Body = Components.Schemas.ApiRequestBodies.UploadFile.Body0;
        export type Input = {
            readonly body?: Body;
            readonly petId: Parameters.PetId;
        };
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.UploadFile.Response200.Schema0;
        }
        export namespace Parameters {
            export type PetId = NonNullable<number>;
        }
    }
    export namespace GetInventory {
        export type Input = {};
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.GetInventory.Response200.Schema0;
        }
    }
    export namespace PlaceOrder {
        export type Body = Components.Schemas.ApiRequestBodies.PlaceOrder.Body0;
        export type Input = {
            readonly body: Body;
        };
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.PlaceOrder.Response200.Schema0 | Components.Schemas.ApiResponses.PlaceOrder.Response200.Schema1;
        }
    }
    export namespace GetOrderById {
        export type Input = {
            readonly orderId: Parameters.OrderId;
        };
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.GetOrderById.Response200.Schema0 | Components.Schemas.ApiResponses.GetOrderById.Response200.Schema1;
        }
        export namespace Parameters {
            export type OrderId = NonNullable<number>;
        }
    }
    export namespace DeleteOrder {
        export type Input = {
            readonly orderId: Parameters.OrderId;
        };
        export type Output = any;
        export namespace Parameters {
            export type OrderId = NonNullable<string>;
        }
    }
    export namespace CreateUser {
        export type Body = Components.Schemas.ApiRequestBodies.CreateUser.Body0;
        export type Input = {
            readonly body: Body;
        };
        export type Output = any;
    }
    export namespace CreateUsersWithArrayInput {
        export type Body = Components.Schemas.ApiRequestBodies.CreateUsersWithArrayInput.Body0;
        export type Input = {
            readonly body: Body;
        };
        export type Output = any;
    }
    export namespace CreateUsersWithListInput {
        export type Body = Components.Schemas.ApiRequestBodies.CreateUsersWithListInput.Body0;
        export type Input = {
            readonly body: Body;
        };
        export type Output = any;
    }
    export namespace LoginUser {
        export type Input = {
            readonly username: Parameters.Username;
            readonly password: Parameters.Password;
        };
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                xRateLimit?: NonNullable<number>;
                xExpiresAfter?: NonNullable<string>;
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.LoginUser.Response200.Schema0 | Components.Schemas.ApiResponses.LoginUser.Response200.Schema1;
        }
        export namespace Parameters {
            export type Username = NonNullable<string>;
            export type Password = NonNullable<string>;
        }
    }
    export namespace LogoutUser {
        export type Input = {};
        export type Output = any;
    }
    export namespace GetUserByName {
        export type Input = {
            readonly username: Parameters.Username;
        };
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.GetUserByName.Response200.Schema0 | Components.Schemas.ApiResponses.GetUserByName.Response200.Schema1;
        }
        export namespace Parameters {
            export type Username = NonNullable<string>;
        }
    }
    export namespace UpdateUser {
        export type Body = Components.Schemas.ApiRequestBodies.UpdateUser.Body0;
        export type Input = {
            readonly body: Body;
            readonly username: Parameters.Username;
        };
        export type Output = any;
        export namespace Parameters {
            export type Username = NonNullable<string>;
        }
    }
    export namespace DeleteUser {
        export type Input = {
            readonly username: Parameters.Username;
        };
        export type Output = any;
        export namespace Parameters {
            export type Username = NonNullable<string>;
        }
    }
}
declare namespace Components {
    export namespace Schemas {
        export type Pet = NonNullable<{
            id?: NonNullable<number>;
            category?: Components.Schemas.Category;
            name: NonNullable<string>;
            photoUrls: NonNullable<NonNullable<string>[]>;
            tags?: NonNullable<Components.Schemas.Tag[]>;
            status?: \\"available\\" | \\"pending\\" | \\"sold\\";
        }>;
        export type Body = NonNullable<{
            name?: NonNullable<string>;
            status?: NonNullable<string>;
        }>;
        export type Body_1 = NonNullable<{
            additionalMetadata?: NonNullable<string>;
            file?: NonNullable<string>;
        }>;
        export type ApiResponse = NonNullable<{
            code?: NonNullable<number>;
            type?: NonNullable<string>;
            message?: NonNullable<string>;
        }>;
        export type Order = NonNullable<{
            id?: NonNullable<number>;
            petId?: NonNullable<number>;
            quantity?: NonNullable<number>;
            shipDate?: NonNullable<string>;
            status?: \\"placed\\" | \\"approved\\" | \\"delivered\\";
            complete?: NonNullable<boolean>;
        }>;
        export type User = NonNullable<{
            id?: NonNullable<number>;
            username?: NonNullable<string>;
            firstName?: NonNullable<string>;
            lastName?: NonNullable<string>;
            email?: NonNullable<string>;
            password?: NonNullable<string>;
            phone?: NonNullable<string>;
            userStatus?: NonNullable<number>;
        }>;
        export type Category = NonNullable<{
            id?: NonNullable<number>;
            name?: NonNullable<string>;
        }>;
        export type Tag = NonNullable<{
            id?: NonNullable<number>;
            name?: NonNullable<string>;
        }>;
        export namespace ApiRequestBodies {
            export namespace UpdatePet {
                export type Body0 = Components.Schemas.Pet;
                export type Body1 = Components.Schemas.Pet;
            }
            export namespace AddPet {
                export type Body0 = Components.Schemas.Pet;
                export type Body1 = Components.Schemas.Pet;
            }
            export namespace UpdatePetWithForm {
                export type Body0 = Components.Schemas.Body;
            }
            export namespace UploadFile {
                export type Body0 = Components.Schemas.Body_1;
            }
            export namespace PlaceOrder {
                export type Body0 = Components.Schemas.Order;
            }
            export namespace CreateUser {
                export type Body0 = Components.Schemas.User;
            }
            export namespace CreateUsersWithArrayInput {
                export type Body0 = NonNullable<Components.Schemas.User[]>;
            }
            export namespace CreateUsersWithListInput {
                export type Body0 = NonNullable<Components.Schemas.User[]>;
            }
            export namespace UpdateUser {
                export type Body0 = Components.Schemas.User;
            }
        }
        export namespace ApiResponses {
            export namespace FindPetsByStatus {
                export namespace Response200 {
                    export type Schema0 = NonNullable<Components.Schemas.Pet[]>;
                    export type Schema1 = NonNullable<Components.Schemas.Pet[]>;
                }
            }
            export namespace FindPetsByTags {
                export namespace Response200 {
                    export type Schema0 = NonNullable<Components.Schemas.Pet[]>;
                    export type Schema1 = NonNullable<Components.Schemas.Pet[]>;
                }
            }
            export namespace GetPetById {
                export namespace Response200 {
                    export type Schema0 = Components.Schemas.Pet;
                    export type Schema1 = Components.Schemas.Pet;
                }
            }
            export namespace UploadFile {
                export namespace Response200 {
                    export type Schema0 = Components.Schemas.ApiResponse;
                }
            }
            export namespace GetInventory {
                export namespace Response200 {
                    export type Schema0 = NonNullable<{
                        [pattern: string]: any;
                    }>;
                }
            }
            export namespace PlaceOrder {
                export namespace Response200 {
                    export type Schema0 = Components.Schemas.Order;
                    export type Schema1 = Components.Schemas.Order;
                }
            }
            export namespace GetOrderById {
                export namespace Response200 {
                    export type Schema0 = Components.Schemas.Order;
                    export type Schema1 = Components.Schemas.Order;
                }
            }
            export namespace LoginUser {
                export namespace Response200 {
                    export type Schema0 = NonNullable<string>;
                    export type Schema1 = NonNullable<string>;
                }
            }
            export namespace GetUserByName {
                export namespace Response200 {
                    export type Schema0 = Components.Schemas.User;
                    export type Schema1 = Components.Schemas.User;
                }
            }
        }
    }
}

import type { AxiosRequestConfig } from 'axios';
import querystring from 'querystring';
import axios from 'axios';

/**
 * This is a sample server Petstore server. For this sample, you can use the api key \`special-key\` to test the authorization filters. For OAuth2 flow, you may use \`user\` as both username and password when asked to login.
 * @module API
 * @version 1.0.0
 */
const API = {
  updatePet,
  addPet,
  findPetsByStatus,
  findPetsByTags,
  getPetById,
  updatePetWithForm,
  deletePet,
  uploadFile,
  getInventory,
  placeOrder,
  getOrderById,
  deleteOrder,
  createUser,
  createUsersWithArrayInput,
  createUsersWithListInput,
  loginUser,
  logoutUser,
  getUserByName,
  updateUser,
  deleteUser,
};


/**
 * Update an existing pet
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function updatePet(
  {
    body,
  } : APITypes.UpdatePet.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.UpdatePet.Output>> {



  const method = 'put';
  const urlParts = [
    'pet',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UpdatePet.Output;
}

/**
 * Add a new pet to the store
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function addPet(
  {
    body,
  } : APITypes.AddPet.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.AddPet.Output>> {



  const method = 'post';
  const urlParts = [
    'pet',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.AddPet.Output;
}

/**
 * Finds Pets by status
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {array} parameters.status
 * Status values that need to be considered for filter
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function findPetsByStatus(
  {
  status,
  } : APITypes.FindPetsByStatus.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.FindPetsByStatus.Output>> {


  if( status == null) {
    throw new Error('Missing required parameter : status. Value : ' +  status);
  }


  const method = 'get';
  const urlParts = [
    'pet',
    'findByStatus',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
    status: status,
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.FindPetsByStatus.Output;
}

/**
 * Finds Pets by tags
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {array} parameters.tags
 * Tags to filter by
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function findPetsByTags(
  {
  tags,
  } : APITypes.FindPetsByTags.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.FindPetsByTags.Output>> {


  if( tags == null) {
    throw new Error('Missing required parameter : tags. Value : ' +  tags);
  }


  const method = 'get';
  const urlParts = [
    'pet',
    'findByTags',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
    tags: tags,
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.FindPetsByTags.Output;
}

/**
 * Find pet by ID
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {integer} parameters.petId
 * ID of pet to return
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getPetById(
  {
  petId,
  } : APITypes.GetPetById.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetPetById.Output>> {


  if( petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }


  const method = 'get';
  const urlParts = [
    'pet',
    petId,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetPetById.Output;
}

/**
 * Updates a pet in the store with form data
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {integer} parameters.petId
 * ID of pet that needs to be updated
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function updatePetWithForm(
  {
    body,
  petId,
  } : APITypes.UpdatePetWithForm.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.UpdatePetWithForm.Output>> {


  if( petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }


  const method = 'post';
  const urlParts = [
    'pet',
    petId,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UpdatePetWithForm.Output;
}

/**
 * Deletes a pet
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {string} [parameters.apiKey],
 * @param {integer} parameters.petId
 * Pet id to delete
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function deletePet(
  {
  apiKey,
  petId,
  } : APITypes.DeletePet.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.DeletePet.Output>> {


  if( petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }


  const method = 'delete';
  const urlParts = [
    'pet',
    petId,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
    'api_key': apiKey,
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.DeletePet.Output;
}

/**
 * uploads an image
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {integer} parameters.petId
 * ID of pet to update
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function uploadFile(
  {
    body,
  petId,
  } : APITypes.UploadFile.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.UploadFile.Output>> {


  if( petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }


  const method = 'post';
  const urlParts = [
    'pet',
    petId,
    'uploadImage',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UploadFile.Output;
}

/**
 * Returns pet inventories by status
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getInventory(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetInventory.Output>> {



  const method = 'get';
  const urlParts = [
    'store',
    'inventory',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetInventory.Output;
}

/**
 * Place an order for a pet
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function placeOrder(
  {
    body,
  } : APITypes.PlaceOrder.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.PlaceOrder.Output>> {



  const method = 'post';
  const urlParts = [
    'store',
    'order',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.PlaceOrder.Output;
}

/**
 * Find purchase order by ID
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getOrderById(
  {
  orderId,
  } : APITypes.GetOrderById.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetOrderById.Output>> {


  if( orderId == null) {
    throw new Error('Missing required parameter : orderId. Value : ' +  orderId);
  }


  const method = 'get';
  const urlParts = [
    'store',
    'order',
    orderId,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetOrderById.Output;
}

/**
 * Delete purchase order by ID
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function deleteOrder(
  {
  orderId,
  } : APITypes.DeleteOrder.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.DeleteOrder.Output>> {


  if( orderId == null) {
    throw new Error('Missing required parameter : orderId. Value : ' +  orderId);
  }


  const method = 'delete';
  const urlParts = [
    'store',
    'order',
    orderId,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.DeleteOrder.Output;
}

/**
 * Create user
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function createUser(
  {
    body,
  } : APITypes.CreateUser.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.CreateUser.Output>> {



  const method = 'post';
  const urlParts = [
    'user',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.CreateUser.Output;
}

/**
 * Creates list of users with given input array
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function createUsersWithArrayInput(
  {
    body,
  } : APITypes.CreateUsersWithArrayInput.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.CreateUsersWithArrayInput.Output>> {



  const method = 'post';
  const urlParts = [
    'user',
    'createWithArray',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.CreateUsersWithArrayInput.Output;
}

/**
 * Creates list of users with given input array
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function createUsersWithListInput(
  {
    body,
  } : APITypes.CreateUsersWithListInput.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.CreateUsersWithListInput.Output>> {



  const method = 'post';
  const urlParts = [
    'user',
    'createWithList',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.CreateUsersWithListInput.Output;
}

/**
 * Logs user into the system
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {string} parameters.username
 * The user name for login,
 * @param {string} parameters.password
 * The password for login in clear text
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function loginUser(
  {
  username,
  password,
  } : APITypes.LoginUser.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.LoginUser.Output>> {


  if( username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }

  if( password == null) {
    throw new Error('Missing required parameter : password. Value : ' +  password);
  }


  const method = 'get';
  const urlParts = [
    'user',
    'login',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
    username: username,
    password: password,
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.LoginUser.Output;
}

/**
 * Logs out current logged in user session
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function logoutUser(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.LogoutUser.Output>> {



  const method = 'get';
  const urlParts = [
    'user',
    'logout',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.LogoutUser.Output;
}

/**
 * Get user by user name
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getUserByName(
  {
  username,
  } : APITypes.GetUserByName.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetUserByName.Output>> {


  if( username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }


  const method = 'get';
  const urlParts = [
    'user',
    username,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetUserByName.Output;
}

/**
 * Updated user
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {string} parameters.username
 * name that need to be deleted
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function updateUser(
  {
    body,
  username,
  } : APITypes.UpdateUser.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.UpdateUser.Output>> {


  if( username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }


  const method = 'put';
  const urlParts = [
    'user',
    username,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UpdateUser.Output;
}

/**
 * Delete user
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {string} parameters.username
 * The name that needs to be deleted
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function deleteUser(
  {
  username,
  } : APITypes.DeleteUser.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.DeleteUser.Output>> {


  if( username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }


  const method = 'delete';
  const urlParts = [
    'user',
    username,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.DeleteUser.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {});
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {});
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with refs 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
type QueryParams = {
  [name: string]: string | number | string[] | number[];
};
type Headers = Record<string, string>;

declare namespace APITypes {
    export namespace PutEcho {
        export type Body = Components.Schemas.ApiRequestBodies.PutEcho.Body0;
        export type Input = {
            readonly body?: Body;
        };
        export type Output = {
            readonly status: 200;
            readonly headers?: NonNullable<{
                [pattern: string]: (NonNullable<string> | NonNullable<NonNullable<string>[]>);
            }>;
            readonly body: Responses.$200;
        };
        export namespace Responses {
            export type $200 = Components.Schemas.ApiResponses.PutEcho.Response200.Schema0;
        }
    }
}
declare namespace Components {
    export namespace Schemas {
        export type Echo = NonNullable<{
            echo: NonNullable<string>;
        }>;
        export namespace ApiRequestBodies {
            export namespace PutEcho {
                export type Body0 = Components.Schemas.Echo;
            }
        }
        export namespace ApiResponses {
            export namespace PutEcho {
                export namespace Response200 {
                    export type Schema0 = NonNullable<{
                        echo: NonNullable<string>;
                    }>;
                }
            }
        }
    }
}

import type { AxiosRequestConfig } from 'axios';
import querystring from 'querystring';
import axios from 'axios';

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  putEcho,
};


/**
 * Echoes what it takes.
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function putEcho(
  {
    body,
  } : APITypes.PutEcho.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.PutEcho.Output>> {



  const method = 'put';
  const urlParts = [
    'echo',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: status => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.PutEcho.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {});
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {});
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`generateSDKFromOpenAPI should work 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
type Headers = Record<string, string>;

export type { APITypes, Components };

declare namespace APITypes {
    export namespace GetOpenAPI {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getOpenAPIResponse200<200>;
        }
    }
    export namespace GetPing {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getPingResponse200<200>;
        }
    }
    export namespace GetDelay {
        export type Output = Responses.$204;
        export type Input = {
            readonly duration: Parameters.Duration;
            readonly cookie?: Parameters.Cookie;
            readonly xApplicationVersion?: Parameters.XApplicationVersion;
        };
        export namespace Responses {
            export type $204 = Components.Responses.getDelayResponse204<204>;
        }
        export namespace Parameters {
            export type Duration = Components.Parameters.GetDelay0;
            export type Cookie = Components.Parameters.GetDelay1;
            export type XApplicationVersion = Components.Parameters.GetDelay2;
        }
    }
    export namespace GetDiagnostic {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getDiagnosticResponse200<200>;
        }
    }
    export namespace GetTime {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getTimeResponse200<200>;
        }
    }
    export namespace PutEcho {
        export type Body = Components.RequestBodies.PutEchoRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.putEchoResponse200<200>;
        }
    }
}
declare namespace Components {
    export namespace RequestBodies {
        export type PutEchoRequestBody = Components.Schemas.RequestBodiesputEchoRequestBodyBody0;
    }
    export namespace Parameters {
        export type GetDelay0 = NonNullable<number>;
        export type GetDelay1 = NonNullable<string>;
        export type GetDelay2 = NonNullable<string>;
    }
    export namespace Responses {
        type getDelayResponse204<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getOpenAPIResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetOpenAPIResponse200Body0;
        };
        type getPingResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetPingResponse200Body0;
        };
        type getDiagnosticResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetDiagnosticResponse200Body0;
        };
        type getTimeResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetTimeResponse200Body0;
        };
        type putEchoResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesputEchoResponse200Body0;
        };
    }
}
declare namespace Components {
    export namespace Schemas {
        export type RequestBodiesputEchoRequestBodyBody0 = NonNullable<{
            echo: NonNullable<string>;
        }>;
        export type ResponsesgetOpenAPIResponse200Body0 = NonNullable<{}>;
        export type ResponsesgetPingResponse200Body0 = NonNullable<{
            pong?: \\"pong\\";
        }>;
        export type ResponsesgetDiagnosticResponse200Body0 = NonNullable<{
            [pattern: string]: unknown;
        }>;
        export type ResponsesgetTimeResponse200Body0 = NonNullable<{
            currentDate?: NonNullable<string>;
        }>;
        export type ResponsesputEchoResponse200Body0 = NonNullable<{
            echo: NonNullable<string>;
        }>;
    }
}

import type { AxiosRequestConfig } from 'axios';
import querystring from 'querystring';
import axios from 'axios';

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getOpenAPI,
  getPing,
  getDelay,
  getDiagnostic,
  getTime,
  putEcho,
};


/**
 * Get API documentation.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getOpenAPI(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetOpenAPI.Output>> {



  const method = 'get';
  const urlParts = [
    'openAPI',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetOpenAPI.Output;
}

/**
 * Checks API's availability.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getPing(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetPing.Output>> {



  const method = 'get';
  const urlParts = [
    'ping',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetPing.Output;
}

/**
 * Answer after a given delay.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {number} parameters.duration
 * Duration in milliseconds
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getDelay(
  {
  duration,
  xApplicationVersion,
  } : APITypes.GetDelay.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetDelay.Output>> {


  if( duration == null) {
    throw new Error('Missing required parameter : duration. Value : ' +  duration);
  }


  const method = 'get';
  const urlParts = [
    'delay',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
    'X-Application-Version': xApplicationVersion,
  });
  const qs = cleanQuery({
    duration: duration,
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetDelay.Output;
}

/**
 * Returns current API's transactions.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getDiagnostic(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetDiagnostic.Output>> {



  const method = 'get';
  const urlParts = [
    'diag',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetDiagnostic.Output;
}

/**
 * Get API internal clock date.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getTime(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetTime.Output>> {



  const method = 'get';
  const urlParts = [
    'time',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetTime.Output;
}

/**
 * Echoes what it takes.
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function putEcho(
  {
    body,
  } : APITypes.PutEcho.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.PutEcho.Output>> {



  const method = 'put';
  const urlParts = [
    'echo',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.PutEcho.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with Pet Store 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
type Headers = Record<string, string>;

export type { APITypes, Components };

declare namespace APITypes {
    export namespace UpdatePet {
        export type Body = Components.RequestBodies.Pet;
        export type Output = Responses.$400 | Responses.$404 | Responses.$405;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $400 = Components.Responses.updatePetResponse400<400>;
            export type $404 = Components.Responses.updatePetResponse404<404>;
            export type $405 = Components.Responses.updatePetResponse405<405>;
        }
    }
    export namespace AddPet {
        export type Body = Components.RequestBodies.Pet;
        export type Output = Responses.$405;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $405 = Components.Responses.addPetResponse405<405>;
        }
    }
    export namespace FindPetsByStatus {
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly status: Parameters.Status;
        };
        export namespace Responses {
            export type $200 = Components.Responses.findPetsByStatusResponse200<200>;
            export type $400 = Components.Responses.findPetsByStatusResponse400<400>;
        }
        export namespace Parameters {
            export type Status = Components.Parameters.FindPetsByStatus0;
        }
    }
    export namespace FindPetsByTags {
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly tags: Parameters.Tags;
        };
        export namespace Responses {
            export type $200 = Components.Responses.findPetsByTagsResponse200<200>;
            export type $400 = Components.Responses.findPetsByTagsResponse400<400>;
        }
        export namespace Parameters {
            export type Tags = Components.Parameters.FindPetsByTags0;
        }
    }
    export namespace GetPetById {
        export type Output = Responses.$200 | Responses.$400 | Responses.$404;
        export type Input = {
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $200 = Components.Responses.getPetByIdResponse200<200>;
            export type $400 = Components.Responses.getPetByIdResponse400<400>;
            export type $404 = Components.Responses.getPetByIdResponse404<404>;
        }
        export namespace Parameters {
            export type PetId = Components.Parameters.GetPetById0;
        }
    }
    export namespace UpdatePetWithForm {
        export type Body = Components.RequestBodies.UpdatePetWithFormRequestBody;
        export type Output = Responses.$405;
        export type Input = {
            readonly body?: Body;
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $405 = Components.Responses.updatePetWithFormResponse405<405>;
        }
        export namespace Parameters {
            export type PetId = Components.Parameters.UpdatePetWithForm0;
        }
    }
    export namespace DeletePet {
        export type Output = Responses.$400;
        export type Input = {
            readonly apiKey?: Parameters.ApiKey;
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $400 = Components.Responses.deletePetResponse400<400>;
        }
        export namespace Parameters {
            export type ApiKey = Components.Parameters.DeletePet0;
            export type PetId = Components.Parameters.DeletePet1;
        }
    }
    export namespace UploadFile {
        export type Body = Components.RequestBodies.UploadFileRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
            readonly petId: Parameters.PetId;
        };
        export namespace Responses {
            export type $200 = Components.Responses.uploadFileResponse200<200>;
        }
        export namespace Parameters {
            export type PetId = Components.Parameters.UploadFile0;
        }
    }
    export namespace GetInventory {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getInventoryResponse200<200>;
        }
    }
    export namespace PlaceOrder {
        export type Body = Components.RequestBodies.PlaceOrderRequestBody;
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.placeOrderResponse200<200>;
            export type $400 = Components.Responses.placeOrderResponse400<400>;
        }
    }
    export namespace GetOrderById {
        export type Output = Responses.$200 | Responses.$400 | Responses.$404;
        export type Input = {
            readonly orderId: Parameters.OrderId;
        };
        export namespace Responses {
            export type $200 = Components.Responses.getOrderByIdResponse200<200>;
            export type $400 = Components.Responses.getOrderByIdResponse400<400>;
            export type $404 = Components.Responses.getOrderByIdResponse404<404>;
        }
        export namespace Parameters {
            export type OrderId = Components.Parameters.GetOrderById0;
        }
    }
    export namespace DeleteOrder {
        export type Output = Responses.$400 | Responses.$404;
        export type Input = {
            readonly orderId: Parameters.OrderId;
        };
        export namespace Responses {
            export type $400 = Components.Responses.deleteOrderResponse400<400>;
            export type $404 = Components.Responses.deleteOrderResponse404<404>;
        }
        export namespace Parameters {
            export type OrderId = Components.Parameters.DeleteOrder0;
        }
    }
    export namespace CreateUser {
        export type Body = Components.RequestBodies.CreateUserRequestBody;
        export type Output = Responses.Default;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $default = Components.Responses.createUserResponsedefault<default>;
        }
    }
    export namespace CreateUsersWithArrayInput {
        export type Body = Components.RequestBodies.UserArray;
        export type Output = Responses.Default;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $default = Components.Responses.createUsersWithArrayInputResponsedefault<default>;
        }
    }
    export namespace CreateUsersWithListInput {
        export type Body = Components.RequestBodies.UserArray;
        export type Output = Responses.Default;
        export type Input = {
            readonly body: Body;
        };
        export namespace Responses {
            export type $default = Components.Responses.createUsersWithListInputResponsedefault<default>;
        }
    }
    export namespace LoginUser {
        export type Output = Responses.$200 | Responses.$400;
        export type Input = {
            readonly username: Parameters.Username;
            readonly password: Parameters.Password;
        };
        export namespace Responses {
            export type $200 = Components.Responses.loginUserResponse200<200>;
            export type $400 = Components.Responses.loginUserResponse400<400>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.LoginUser0;
            export type Password = Components.Parameters.LoginUser1;
        }
    }
    export namespace LogoutUser {
        export type Output = Responses.Default;
        export type Input = {};
        export namespace Responses {
            export type $default = Components.Responses.logoutUserResponsedefault<default>;
        }
    }
    export namespace GetUserByName {
        export type Output = Responses.$200 | Responses.$400 | Responses.$404;
        export type Input = {
            readonly username: Parameters.Username;
        };
        export namespace Responses {
            export type $200 = Components.Responses.getUserByNameResponse200<200>;
            export type $400 = Components.Responses.getUserByNameResponse400<400>;
            export type $404 = Components.Responses.getUserByNameResponse404<404>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.GetUserByName0;
        }
    }
    export namespace UpdateUser {
        export type Body = Components.RequestBodies.UpdateUserRequestBody;
        export type Output = Responses.$400 | Responses.$404;
        export type Input = {
            readonly body: Body;
            readonly username: Parameters.Username;
        };
        export namespace Responses {
            export type $400 = Components.Responses.updateUserResponse400<400>;
            export type $404 = Components.Responses.updateUserResponse404<404>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.UpdateUser0;
        }
    }
    export namespace DeleteUser {
        export type Output = Responses.$400 | Responses.$404;
        export type Input = {
            readonly username: Parameters.Username;
        };
        export namespace Responses {
            export type $400 = Components.Responses.deleteUserResponse400<400>;
            export type $404 = Components.Responses.deleteUserResponse404<404>;
        }
        export namespace Parameters {
            export type Username = Components.Parameters.DeleteUser0;
        }
    }
}
declare namespace Components {
    export namespace RequestBodies {
        export type UserArray = Components.Schemas.RequestBodiesUserArrayBody0;
        export type Pet = Components.Schemas.Pet | Components.Schemas.Pet;
        export type UpdatePetWithFormRequestBody = Components.Schemas.Body;
        export type UploadFileRequestBody = Components.Schemas.Body_1;
        export type PlaceOrderRequestBody = Components.Schemas.Order;
        export type CreateUserRequestBody = Components.Schemas.User;
        export type UpdateUserRequestBody = Components.Schemas.User;
    }
    export namespace Parameters {
        export type GetPetById0 = NonNullable<number>;
        export type UpdatePetWithForm0 = NonNullable<number>;
        export type DeletePet0 = NonNullable<string>;
        export type DeletePet1 = NonNullable<number>;
        export type UploadFile0 = NonNullable<number>;
        export type GetOrderById0 = NonNullable<number>;
        export type DeleteOrder0 = NonNullable<string>;
        export type LoginUser0 = NonNullable<string>;
        export type LoginUser1 = NonNullable<string>;
        export type GetUserByName0 = NonNullable<string>;
        export type UpdateUser0 = NonNullable<string>;
        export type DeleteUser0 = NonNullable<string>;
        export type FindPetsByStatus0 = NonNullable<(\\"available\\" | \\"pending\\" | \\"sold\\")[]>;
        export type FindPetsByTags0 = NonNullable<NonNullable<string>[]>;
    }
    export namespace Responses {
        type updatePetResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type updatePetResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type updatePetResponse405<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type addPetResponse405<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type findPetsByStatusResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type findPetsByTagsResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getPetByIdResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getPetByIdResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type updatePetWithFormResponse405<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type deletePetResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type placeOrderResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getOrderByIdResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getOrderByIdResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type deleteOrderResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type deleteOrderResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type createUserResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type createUsersWithArrayInputResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type createUsersWithListInputResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type loginUserResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type logoutUserResponsedefault<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getUserByNameResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type getUserByNameResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type updateUserResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type updateUserResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type deleteUserResponse400<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type deleteUserResponse404<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body?: NonNullable<unknown>;
        };
        type findPetsByStatusResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesfindPetsByStatusResponse200Body0 | Components.Schemas.ResponsesfindPetsByStatusResponse200Body1;
        };
        type findPetsByTagsResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesfindPetsByTagsResponse200Body0 | Components.Schemas.ResponsesfindPetsByTagsResponse200Body1;
        };
        type getPetByIdResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.Pet | Components.Schemas.Pet;
        };
        type uploadFileResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ApiResponse;
        };
        type getInventoryResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetInventoryResponse200Body0;
        };
        type placeOrderResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.Order | Components.Schemas.Order;
        };
        type getOrderByIdResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.Order | Components.Schemas.Order;
        };
        type getUserByNameResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.User | Components.Schemas.User;
        };
        type loginUserResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly \\"x-rate-limit\\"?: Components.Headers.LoginUserResponse200HeadersXRateLimit;
                readonly \\"x-expires-after\\"?: Components.Headers.LoginUserResponse200HeadersXExpiresAfter;
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesloginUserResponse200Body0 | Components.Schemas.ResponsesloginUserResponse200Body1;
        };
    }
    export namespace Headers {
        export type LoginUserResponse200HeadersXRateLimit = NonNullable<number>;
        export type LoginUserResponse200HeadersXExpiresAfter = NonNullable<string>;
    }
}
declare namespace Components {
    export namespace Schemas {
        export type RequestBodiesUserArrayBody0 = NonNullable<Components.Schemas.User[]>;
        export type Pet = NonNullable<{
            id?: NonNullable<number>;
            category?: Components.Schemas.Category;
            name: NonNullable<string>;
            photoUrls: NonNullable<NonNullable<string>[]>;
            tags?: NonNullable<Components.Schemas.Tag[]>;
            status?: \\"available\\" | \\"pending\\" | \\"sold\\";
        }>;
        export type Body = NonNullable<{
            name?: NonNullable<string>;
            status?: NonNullable<string>;
        }>;
        export type Body_1 = NonNullable<{
            additionalMetadata?: NonNullable<string>;
            file?: NonNullable<string>;
        }>;
        export type Order = NonNullable<{
            id?: NonNullable<number>;
            petId?: NonNullable<number>;
            quantity?: NonNullable<number>;
            shipDate?: NonNullable<string>;
            status?: \\"placed\\" | \\"approved\\" | \\"delivered\\";
            complete?: NonNullable<boolean>;
        }>;
        export type User = NonNullable<{
            id?: NonNullable<number>;
            username?: NonNullable<string>;
            firstName?: NonNullable<string>;
            lastName?: NonNullable<string>;
            email?: NonNullable<string>;
            password?: NonNullable<string>;
            phone?: NonNullable<string>;
            userStatus?: NonNullable<number>;
        }>;
        export type ResponsesfindPetsByStatusResponse200Body0 = NonNullable<Components.Schemas.Pet[]>;
        export type ResponsesfindPetsByStatusResponse200Body1 = NonNullable<Components.Schemas.Pet[]>;
        export type ResponsesfindPetsByTagsResponse200Body0 = NonNullable<Components.Schemas.Pet[]>;
        export type ResponsesfindPetsByTagsResponse200Body1 = NonNullable<Components.Schemas.Pet[]>;
        export type ApiResponse = NonNullable<{
            code?: NonNullable<number>;
            type?: NonNullable<string>;
            message?: NonNullable<string>;
        }>;
        export type ResponsesgetInventoryResponse200Body0 = NonNullable<{
            [pattern: string]: unknown;
        }>;
        export type ResponsesloginUserResponse200Body0 = NonNullable<string>;
        export type ResponsesloginUserResponse200Body1 = NonNullable<string>;
        export type Category = NonNullable<{
            id?: NonNullable<number>;
            name?: NonNullable<string>;
        }>;
        export type Tag = NonNullable<{
            id?: NonNullable<number>;
            name?: NonNullable<string>;
        }>;
    }
}

import type { AxiosRequestConfig } from 'axios';
import querystring from 'querystring';
import axios from 'axios';

/**
 * This is a sample server Petstore server. For this sample, you can use the api key \`special-key\` to test the authorization filters. For OAuth2 flow, you may use \`user\` as both username and password when asked to login.
 * @module API
 * @version 1.0.0
 */
const API = {
  updatePet,
  addPet,
  findPetsByStatus,
  findPetsByTags,
  getPetById,
  updatePetWithForm,
  deletePet,
  uploadFile,
  getInventory,
  placeOrder,
  getOrderById,
  deleteOrder,
  createUser,
  createUsersWithArrayInput,
  createUsersWithListInput,
  loginUser,
  logoutUser,
  getUserByName,
  updateUser,
  deleteUser,
};


/**
 * Update an existing pet
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function updatePet(
  {
    body,
  } : APITypes.UpdatePet.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.UpdatePet.Output>> {



  const method = 'put';
  const urlParts = [
    'pet',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UpdatePet.Output;
}

/**
 * Add a new pet to the store
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function addPet(
  {
    body,
  } : APITypes.AddPet.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.AddPet.Output>> {



  const method = 'post';
  const urlParts = [
    'pet',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.AddPet.Output;
}

/**
 * Finds Pets by status
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {array} parameters.status
 * Status values that need to be considered for filter
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function findPetsByStatus(
  {
  status,
  } : APITypes.FindPetsByStatus.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.FindPetsByStatus.Output>> {


  if( status == null) {
    throw new Error('Missing required parameter : status. Value : ' +  status);
  }


  const method = 'get';
  const urlParts = [
    'pet',
    'findByStatus',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
    status: status,
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.FindPetsByStatus.Output;
}

/**
 * Finds Pets by tags
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {array} parameters.tags
 * Tags to filter by
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function findPetsByTags(
  {
  tags,
  } : APITypes.FindPetsByTags.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.FindPetsByTags.Output>> {


  if( tags == null) {
    throw new Error('Missing required parameter : tags. Value : ' +  tags);
  }


  const method = 'get';
  const urlParts = [
    'pet',
    'findByTags',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
    tags: tags,
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.FindPetsByTags.Output;
}

/**
 * Find pet by ID
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {integer} parameters.petId
 * ID of pet to return
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getPetById(
  {
  petId,
  } : APITypes.GetPetById.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetPetById.Output>> {


  if( petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }


  const method = 'get';
  const urlParts = [
    'pet',
    petId,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetPetById.Output;
}

/**
 * Updates a pet in the store with form data
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {integer} parameters.petId
 * ID of pet that needs to be updated
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function updatePetWithForm(
  {
    body,
  petId,
  } : APITypes.UpdatePetWithForm.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.UpdatePetWithForm.Output>> {


  if( petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }


  const method = 'post';
  const urlParts = [
    'pet',
    petId,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UpdatePetWithForm.Output;
}

/**
 * Deletes a pet
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {string} [parameters.apiKey],
 * @param {integer} parameters.petId
 * Pet id to delete
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function deletePet(
  {
  apiKey,
  petId,
  } : APITypes.DeletePet.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.DeletePet.Output>> {


  if( petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }


  const method = 'delete';
  const urlParts = [
    'pet',
    petId,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
    'api_key': apiKey,
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.DeletePet.Output;
}

/**
 * uploads an image
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {integer} parameters.petId
 * ID of pet to update
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function uploadFile(
  {
    body,
  petId,
  } : APITypes.UploadFile.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.UploadFile.Output>> {


  if( petId == null) {
    throw new Error('Missing required parameter : petId. Value : ' +  petId);
  }


  const method = 'post';
  const urlParts = [
    'pet',
    petId,
    'uploadImage',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UploadFile.Output;
}

/**
 * Returns pet inventories by status
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getInventory(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetInventory.Output>> {



  const method = 'get';
  const urlParts = [
    'store',
    'inventory',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetInventory.Output;
}

/**
 * Place an order for a pet
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function placeOrder(
  {
    body,
  } : APITypes.PlaceOrder.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.PlaceOrder.Output>> {



  const method = 'post';
  const urlParts = [
    'store',
    'order',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.PlaceOrder.Output;
}

/**
 * Find purchase order by ID
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {integer} parameters.orderId
 * ID of pet that needs to be fetched
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getOrderById(
  {
  orderId,
  } : APITypes.GetOrderById.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetOrderById.Output>> {


  if( orderId == null) {
    throw new Error('Missing required parameter : orderId. Value : ' +  orderId);
  }


  const method = 'get';
  const urlParts = [
    'store',
    'order',
    orderId,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetOrderById.Output;
}

/**
 * Delete purchase order by ID
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {string} parameters.orderId
 * ID of the order that needs to be deleted
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function deleteOrder(
  {
  orderId,
  } : APITypes.DeleteOrder.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.DeleteOrder.Output>> {


  if( orderId == null) {
    throw new Error('Missing required parameter : orderId. Value : ' +  orderId);
  }


  const method = 'delete';
  const urlParts = [
    'store',
    'order',
    orderId,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.DeleteOrder.Output;
}

/**
 * Create user
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function createUser(
  {
    body,
  } : APITypes.CreateUser.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.CreateUser.Output>> {



  const method = 'post';
  const urlParts = [
    'user',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.CreateUser.Output;
}

/**
 * Creates list of users with given input array
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function createUsersWithArrayInput(
  {
    body,
  } : APITypes.CreateUsersWithArrayInput.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.CreateUsersWithArrayInput.Output>> {



  const method = 'post';
  const urlParts = [
    'user',
    'createWithArray',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.CreateUsersWithArrayInput.Output;
}

/**
 * Creates list of users with given input array
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function createUsersWithListInput(
  {
    body,
  } : APITypes.CreateUsersWithListInput.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.CreateUsersWithListInput.Output>> {



  const method = 'post';
  const urlParts = [
    'user',
    'createWithList',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.CreateUsersWithListInput.Output;
}

/**
 * Logs user into the system
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {string} parameters.username
 * The user name for login,
 * @param {string} parameters.password
 * The password for login in clear text
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function loginUser(
  {
  username,
  password,
  } : APITypes.LoginUser.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.LoginUser.Output>> {


  if( username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }

  if( password == null) {
    throw new Error('Missing required parameter : password. Value : ' +  password);
  }


  const method = 'get';
  const urlParts = [
    'user',
    'login',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
    username: username,
    password: password,
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.LoginUser.Output;
}

/**
 * Logs out current logged in user session
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function logoutUser(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.LogoutUser.Output>> {



  const method = 'get';
  const urlParts = [
    'user',
    'logout',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.LogoutUser.Output;
}

/**
 * Get user by user name
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {string} parameters.username
 * The name that needs to be fetched. Use user1 for testing.
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getUserByName(
  {
  username,
  } : APITypes.GetUserByName.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetUserByName.Output>> {


  if( username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }


  const method = 'get';
  const urlParts = [
    'user',
    username,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetUserByName.Output;
}

/**
 * Updated user
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {string} parameters.username
 * name that need to be deleted
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function updateUser(
  {
    body,
  username,
  } : APITypes.UpdateUser.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.UpdateUser.Output>> {


  if( username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }


  const method = 'put';
  const urlParts = [
    'user',
    username,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.UpdateUser.Output;
}

/**
 * Delete user
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {string} parameters.username
 * The name that needs to be deleted
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function deleteUser(
  {
  username,
  } : APITypes.DeleteUser.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.DeleteUser.Output>> {


  if( username == null) {
    throw new Error('Missing required parameter : username. Value : ' +  username);
  }


  const method = 'delete';
  const urlParts = [
    'user',
    username,
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '1.0.0',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.DeleteUser.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with filterStatuses 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
type Headers = Record<string, string>;

export type { APITypes, Components };

declare namespace APITypes {
    export namespace GetPing {
        export type Output = Responses.$200;
        export type Input = {};
        export namespace Responses {
            export type $200 = Components.Responses.getPingResponse200<200>;
        }
    }
}
declare namespace Components {
    export namespace Responses {
        type getPingResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesgetPingResponse200Body0;
        };
    }
}
declare namespace Components {
    export namespace Schemas {
        export type ResponsesgetPingResponse200Body0 = NonNullable<{
            pong?: \\"pong\\";
        }>;
    }
}

import type { AxiosRequestConfig } from 'axios';
import querystring from 'querystring';
import axios from 'axios';

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  getPing,
};


/**
 * Checks API's availability.
 * @param {Object} parameters
 * The parameters to provide (destructured)
 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function getPing(
  _: unknown,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.GetPing.Output>> {



  const method = 'get';
  const urlParts = [
    'ping',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = undefined;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.GetPing.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;

exports[`generateSDKFromOpenAPI should work with refs 1`] = `
"/* tslint:disable */
/* eslint-disable */
// WARNING: This file is automatically generated
// do not change it in place it would be overridden
// by the next build

type Writeable<T extends { [x: string]: unknown }> = {
  [P in keyof T]: T[P];
};
type QueryParams = {
  [name: string]: string | number | string[] | number[] | boolean | undefined;
};
type Headers = Record<string, string>;

export type { APITypes, Components };

declare namespace APITypes {
    export namespace PutEcho {
        export type Body = Components.RequestBodies.PutEchoRequestBody;
        export type Output = Responses.$200;
        export type Input = {
            readonly body?: Body;
        };
        export namespace Responses {
            export type $200 = Components.Responses.putEchoResponse200<200>;
        }
    }
}
declare namespace Components {
    export namespace RequestBodies {
        export type PutEchoRequestBody = Components.Schemas.Echo;
    }
    export namespace Responses {
        type putEchoResponse200<S extends number> = {
            readonly status: S;
            readonly headers?: {
                readonly [name: string]: unknown;
            };
            readonly body: Components.Schemas.ResponsesputEchoResponse200Body0;
        };
    }
}
declare namespace Components {
    export namespace Schemas {
        export type Echo = NonNullable<{
            echo: NonNullable<string>;
        }>;
        export type ResponsesputEchoResponse200Body0 = NonNullable<{
            echo: NonNullable<string>;
        }>;
    }
}

import type { AxiosRequestConfig } from 'axios';
import querystring from 'querystring';
import axios from 'axios';

/**
 * A basic Whook server
 * @module API
 * @version 3.1.3
 */
const API = {
  putEcho,
};


/**
 * Echoes what it takes.
 * @param {Object} parameters
 * The parameters to provide (destructured)
  @param body The request body

 * @param {Object} options
 * Options to override Axios request configuration
 * @return {Object}
 * The HTTP response
 */
async function putEcho(
  {
    body,
  } : APITypes.PutEcho.Input,
  options: AxiosRequestConfig = {}
) : Promise<Writeable<APITypes.PutEcho.Output>> {



  const method = 'put';
  const urlParts = [
    'echo',
  ];
  const headers = Object.assign(((options || {}).headers || {}), {
    'X-API-Version': '3.1.3',
    'X-SDK-Version': '1.0.0',
  });
  const qs = cleanQuery({
  });
  const data = body;

  const response = await axios(Object.assign({
    baseURL: 'http://192.168.10.149:8000/v3',
    paramsSerializer: querystring.stringify.bind(querystring),
    validateStatus: (status: number) => 200 <= status && 300 > status,
    method: method,
    url: urlParts.join('/'),
    headers: cleanHeaders(headers),
    params: qs,
    data,
  }, options || {}));

  return {
    status: response.status,
    headers: response.headers,
    body: response.data,
  } as APITypes.PutEcho.Output;
}

function cleanQuery(query: QueryParams): QueryParams {
    return Object.keys(query)
    .filter(key => \\"undefined\\" !== typeof query[key])
    .filter(key => !(query[key] instanceof Array) || 0 !== (query[key] as any[]).length)
    .reduce((newQuery, key) => {
        newQuery[key] = query[key];
        return newQuery;
    }, {} as QueryParams);
}

export function cleanHeaders(headers: Headers): Headers {
    return Object.keys(headers)
    .filter(key => \\"undefined\\" !== typeof headers[key])
    .reduce((newHeaders, key) => {
        newHeaders[key] = headers[key];
        return newHeaders;
    }, {} as Headers);
}

export function sortMultipleQuery(a: number, b: number): number {
    return a > b ? 1 : -1;
}

export default API;
"
`;
